
Being able to effortlessly cross-compile binaries for different architectures adds much convenience to the developer workflows of the people involved, but often, these workflows do not stop at building the binaries but also include running tests. If the software also compiles on the host toolchain and the tests are generic enough, running tests on the host might be the easiest way to test the software, although it might cost some time when switching the toolchains and rebuilding frequently. If this is not possible or too timeconsuming, one alternative is of course to run any tests on the real target hardware, but depending on the availability of the hardware and the effort of setting up the tests on the hardware, this might also be rather cumbersome. So, often, a practicable middle way is to run tests inside an emulator for the target platform if this is available.

To define an emulator for running tests, the CROSSCOMPILING\_EMULATOR target property is used. It can either be set for individual targets or globally by setting the CMAKE\_CROSSCOMPILING\_EMULATOR cache variable, which contains a semicolonseparated list of the command and arguments to run the emulator. If set globally, the command will be prefixed to all commands specified in add\_test(), add\_custom\_command(), and add\_custom\_target(), and it will be used to run any executables generated by try\_run() commands. This means that all custom commands that are used for a build must be accessible and runnable inside the emulator as well. The CROSSCOMPILING\_EMULATOR property does not necessarily have to be an actual emulatorâ€”it can be any arbitrary program, such as a script that copies the binaries to a target machine and executes it there.

Setting CMAKE\_CROSSCOMPILING\_EMULATOR should either happen over a toolchain
file, the command line, or a configured prefix. An example toolchain file used for cross-compiling C++ code for ARM that uses the popular open source emulator QEMU to run the tests could look like this:

\begin{lstlisting}[style=styleCMake]
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(CMAKE_SYSROOT /path/to/arm/sysroot/)
set(CMAKE_CXX_COMPILER /usr/bin/clang++)
set(CMAKE_CXX_COMPILER_TARGET arm-linux-gnueabihf)

set(CMAKE_CROSSCOMPILING_EMULATOR "qemu-arm;-L;${CMAKE_	SYSROOT}")
\end{lstlisting}

In addition to setting the information of the target system and the toolchain for crosscompiling the last line in the example, it sets the emulator command to qemu-arm -L/path/to/arm/sysroot. Let's assume a CMakeLists.txt file contains a test defined like this:

\begin{lstlisting}[style=styleCMake]
add_test(NAME exampleTest COMMAND exampleExe)
\end{lstlisting}

When CTest is run instead of running exampleExe directly, the test command is transformed into the following:

\begin{tcblisting}{commandshell={}}
qemu-arm "-L" "/path/to/arm/sysroot/" "/path/to/build-dir/
  exampleExe"
\end{tcblisting}

Running tests in an emulator can speed up developer workflows quite a bit, as it might eliminate the need to switch between the host toolchain and the target toolchain and does not require the build artifacts to be moved to the target hardware for each superficial test. Using emulators like this also comes in handy for Continuous Integration (CI) builds where it might be hard to build on the real target hardware.

A trick regarding CMAKE\_CROSSCOMPILING\_EMULATOR is that it also can be used to temporarily wrap tests in a diagnostic utility such as Valgrind or similar diagnostic tools. As running the specified emulator executable is not dependent on the CMAKE\_CROSSCOMPILING variable, which indicates whether a project is cross-compiled or not, a common pitfall with this workaround is that setting the CMAKE\_CROSSCOMPILING\_EMULATOR variable will impact the try\_run() command often used to test for supported features of the toolchain or any dependencies, and as a diagnostic utility might cause a compiler test to fail, it might be necessary to run it on an already cached build where any results of try\_run() are already cached. Because of this, using the CMAKE\_CROSSCOMPILING\_EMULATOR variable to run diagnostic utilities should not be done permanently but rather in a specific development situation, when hunting defects.

In this section, we mentioned CMake's try\_run() command, which, along with the closely related try\_compile() command, is used to check for the availability of certain features in the compiler or the toolchain. In the next section, we will have a closer look at the two commands and into feature testing toolchains.

\subsubsubsection{12.4.1\hspace{0.2cm}Testing a toolchain for supported features}

When CMake is run for the first time on a project tree, it performs various tests for compiler and language features. Any call to project() or enable\_language() will trigger testing again, but the results may already be cached from a previous run. Caching is also the reason why switching toolchains on an existing build is not recommended. As we will see in this section, CMake can check for quite a few features out of the box.

Most of the checks will internally use the try\_compile() command to perform these tests. This command essentially builds a small binary with the toolchain that is either detected or supplied by the user. All relevant global variables such as CMAKE\_<LANG>\_FLAGS will be forwarded to try\_compile().

Closely related to it is the try\_run() command, which internally calls try\_compile() and, if that succeeds, will try to run the program. For regular compiler checks, try\_run() is not used, and any calls to it are usually defined in the project.

To write custom checks, rather than invoking try\_compile() and try\_run() directly, it is recommended to use the CheckSourceCompiles or CheckSourceRuns modules and the respective functions' check\_source\_compiles() and check\_source\_runs() commands, which have been available since CMake 3.19. For most cases, they will suffice to produce the needed information without the need for more complicated handling of try\_compile() or try\_run(). The signatures of the two commands are very similar, as we can see here:

\begin{lstlisting}[style=styleCMake]
check_source_compiles(<lang> <code> <resultVar>
	[FAIL_REGEX <regex1> [<regex2>...]] [SRC_EXT <extension>])
check_source_runs(<lang> <code> <resultVar>
[SRC_EXT <extension>])
\end{lstlisting}

The <lang> parameter specifies one of the languages supported by CMake, such as C or CXX for C++. <code> is the code as a string to be linked as an executable, so it must contain a main() function. The result of the compilation will be stored as a Boolean value in the <resultVar> cache variable. If FAIL\_REGEX is provided for check\_source\_compiles, the output of the compilation will be checked against the expressions supplied. The code will be saved in a temporary file with the extension matching the language selected; if the file should have a different extension than the default, it can be specified by the SRC\_EXT option.

There are also language-specific versions of the modules called Check<LANG>SourceCompiles and Check<LANG>SourceRuns that provide the respective command, as illustrated in the following example:

\begin{lstlisting}[style=styleCMake]
include(CheckCSourceCompiles)
check_c_source_compiles(code resultVar
	[FAIL_REGEX regexes...]
)

include(CheckCXXSourceCompiles)
check_cxx_source_compiles(code resultVar
	[FAIL_REGEX regexes...]
)
\end{lstlisting}

Let's assume that there is a C++ project that could either use the atomics functionality of the standard library or, if this is not supported, fall back to a different implementation. A compiler check for this could look like this:

\begin{lstlisting}[style=styleCMake]
include(CheckSourceCompiles)

check_source_compiles(CXX "
#include <atomic>
int main(){
	std::atomic<unsigned int> x;
	x.fetch_add(1);
	x.fetch_sub(1);
}" HAS_STD_ATOMIC)
\end{lstlisting}

After including the module, the check\_source\_compiles() function is called with a small program that uses the functionality to be checked. If the code compiles successfully, HAS\_STD\_ATOMIC will be set to true; else, it will be set to false. The test is executed during the configuration of the project and will print a status message like this:

\begin{tcblisting}{commandshell={}}
[cmake] -- Performing Test HAS_STD_ATOMIC
[cmake] -- Performing Test HAS_STD_ATOMIC - Success
\end{tcblisting}

The result will be cached so that any subsequent run of CMake will not perform the test again. In a lot of cases, checking whether a program compiles already gives enough information about a certain feature of the toolchain, but sometimes the underlying program has to be run to obtain the needed information. For this, check\_source\_runs() works analogously to check\_source\_compiles(). One caveat of check\_source\_runs() is this: if CMAKE\_CROSSCOMPILING is set but no emulator command is set, then the test will only compile the test but not run it unless CMAKE\_CROSSCOMPILING\_EMULATOR is set.

There are a number of variables of the form CMAKE\_REQUIRED\_ to control how the checks compile the code. Note that these variables lack the language-specific part, which needs special care if working on projects that run tests for different languages. An explanation of some of these variables is provided here:

\begin{itemize}
\item 
CMAKE\_REQUIRED\_FLAGS is used to pass additional flags to the compiler after any flags specified in the CMAKE\_<LANG>\_FLAGS or CMAKE\_<LANG>\_FLAGS\_<CONFIG> variables.

\item 
CMAKE\_REQUIRED\_DEFINITIONS specifies a number of compiler definitions of the form -DFOO=bar.

\item 
CMAKE\_REQUIRED\_INCLUDES specifies a list of directories to search for additional headers.

\item 
CMAKE\_REQUIRED\_LIBRARIES specifies a list of libraries to add when linking programs. These can be the filenames of the libraries or imported CMake targets.

\item 
CMAKE\_REQUIRED\_LINK\_OPTIONS is a list of additional linker flags.

\item
CMAKE\_REQUIRED\_QUIET may be set to true to suppress any status messages from the checks.
\end{itemize}

In situations where the checks need to be isolated from each other, the CMakePushCheckState module provides the cmake\_push\_check\_state(), cmake\_pop\_check\_state(), and cmake\_reset\_check\_state() functions for storing the configuration, restoring a previous configuration, and resetting the configuration, as illustrated in the following example:

\begin{lstlisting}[style=styleCMake]
include(CMakePushCheckState)
cmake_push_check_state()
# Push the state and clean it to start with a clean check state
cmake_reset_check_state()

include(CheckCompilerFlag)
check_compiler_flag(CXX -Wall WALL_FLAG_SUPPORTED)

if(WALL_FLAG_SUPPORTED)
	set(CMAKE_REQUIRED_FLAGS -Wall)
	
	# Preserve -Wall and add more things for extra checks
	cmake_push_check_state()
	set(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}
		/include)

	include(CheckSymbolExists)
	check_symbol_exists(hello "hello.hpp" HAVE_HELLO_
		SYMBOL)
	
	cmake_pop_check_state()
endif()
# restore all CMAKE_REQUIRED_VARIABLEs to original state
cmake_pop_check_state()
\end{lstlisting}

Underlying the commands for checking compilation or running the test program are the more complicated try\_compile() and try\_run() commands. While available for use, they are mainly intended for internal use, and thus we refer you to the official documentation of the commands instead of explaining them here.

Checking compiler features by compiling and running programs is a very versatile approach to checking for toolchain features. Some checks are so common that CMake provides dedicated modules and functions for them.

\subsubsubsection{12.4.2\hspace{0.2cm}Common checks for toolchain and language features}

For some of the most common feature checks, such as checking whether a compiler flag is supported or whether a header file exists, CMake provides its own modules for convenience. Since CMake 3.19, the general modules that take the language as an argument exist, but the corresponding Check<LANG>... language-specific modules may still be used.

A very basic test to check whether a compiler for a certain language is available is the CheckLanguage module. It can be used to check whether a compiler for a certain language is available if the CMAKE\_<LANG>\_COMPILER variable is not set. An example to check whether Fortran is available could look like this:

\begin{lstlisting}[style=styleCMake]
Include(CheckLanguage)
check_language(Fortran)if(CMAKE_Fortran_COMPILER)
enable_language(Fortran)else() message(STATUS "No Fortran
support")endif()
\end{lstlisting}

If the check succeeds, the corresponding CMAKE\_<LANG>\_COMPILER variable is set. If the variable was set before the check, it has no effect.

CheckCompilerFlag provides the check\_compiler\_flag() function to check whether the current compiler supports a certain flag. Internally, a very simple program will be compiled, and the output will be parsed for a diagnostic message. The check assumes that any compiler flags already present in CMAKE\_<LANG>\_FLAGS will run successfully through; else, the check\_compiler\_flag() function will always fail. The following example checks whether the C++ compiler supports the -Wall flag:

\begin{lstlisting}[style=styleCMake]
include(CheckCompilerFlag)
check_compiler_flag(CXX -Wall WALL_FLAG_SUPPORTED)
\end{lstlisting}

If the -Wall flag is supported, the WALL\_FLAG\_SUPPORTED cache variable will be true; else, it will be false.

The corresponding module to check linker flags is called CheckLinkerFlag and works similarly to the check for compiler flags, but the linker flag will not be passed directly to the linker. As the linker will typically be invoked through the compiler, passing additional flags to the linker may use a prefix such as -Wl or -Xlinker to tell the compiler to pass  the flag through. As this flag is compiler-specific, CMake provides the LINKER: prefix to automatically substitute the command. For example, to pass a flag to generate statistics about execution time and memory consumption to the linker, the following command would be used:

\begin{lstlisting}[style=styleCMake]
include(CheckLinkerFlag)
check_linker_flag(CXX LINKER:-stats LINKER_STATS_FLAG_
	SUPPORTED)
\end{lstlisting}

If the linker supports the -stats flag, the LINKER\_STATS\_FLAG\_SUPPORTED variable will be true.

Other useful modules to check various things are the CheckLibraryExists, CheckIncludeFile, and CheckIncludeFileCXX modules for checking whether a certain library or include file exists in certain locations.

CMake offers even more detailed checks that might be very specific to the project; for example, the CheckSymbolExists and CheckSymbolExistsCXX modules check whether a certain symbol exists either as a preprocessor definition, a variable, or a function. CheckStructHasMember will check whether a struct has a certain member, while CheckTypeSize can check the size of non-user types and the definition of C and C++ function prototypes with CheckPrototypeDefinition.

As we have seen, CMake offers quite a lot of checks, and the list of available checks will probably grow as CMake evolves further. While checks are useful in certain situations, we should be careful not to carry the number of tests too far. The number and complexity of the checks will have quite an impact on the speed of the configuration step while sometimes not providing too much benefit. Having a lot of checks in a project could also be a hint toward the unnecessary complexity of the project.
