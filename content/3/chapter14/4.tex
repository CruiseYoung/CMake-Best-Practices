
Apart from raw compilation time, the main driver for long build times in C++ projects is often unnecessary dependencies between the targets or files. If targets have unnecessary linking requirements between each other, the build system will be limited in executing build tasks in parallel and some of the targets will be frequently relinked. Creating a dependency graph of the targets, as described in Chapter 6, Automatically Generating Documentation, will help identify the dependencies. If the resulting graph looks more like a snarl of rope than a tree, optimizing and refactoring the project structure might bring a lot of performance gains. Tools such as include what you use and link what you use, as described in Chapter 7, Seamlessly Integrating Code Quality Tools with CMake, may further help identify unnecessary dependencies. Another common theme is C or C++ projects that expose too much private information in public headers, often causing frequent rebuilds and reducing the effectiveness of incremental builds.

A relatively safe option to bring performance improvements is to set the CMAKE\_OPTIMIZE\_DEPENDENCIES cache variable to true. This will cause CMake to remove some dependencies for static or object libraries at generation time if they are not needed. If working with a lot of static or object libraries and a deep dependency graph, this might already produce some gains regarding compile time.

Generally speaking, optimizing the project structure and modularizing the code will often have a greater effect on build performance than optimization of the code. On average, compiling and linking a project that consists of many small files takes longer than projects consisting of a few large files. CMake can help improve build performance with so-called unity builds, which merge several files into a larger file.

\subsubsubsection{14.4.1\hspace{0.2cm}Using unity builds}

The unity builds that CMake can support may help with build performance by concatenating multiple files into larger files, thus reducing the number of files to be compiled. This might bring a decrease in build time because include files are processed only once instead of for every smaller file. So, this will have the biggest effect if many of the files include the same header files and if the header files are heavy to digest by the compiler. Generally speaking, these are headers containing lots of macros or template metaprogramming. Creating a unity build may improve build time significantly, especially when using large header-only libraries, such as the Eigen math library. On the other hand, unity builds have the downside that incremental builds might take longer as, usually, larger chunks of the project have to be recompiled and linked when only a single file changes.

By setting the CMAKE\_UNITY\_BUILD cache variable to true, CMake will concatenate the sources into one or more unity sources and build them instead of the original files. The generated files use the unity\_<lang>\_<Nr>.<lang> pattern and are located in a folder called Unity in the build directory for the project. Unity files for C++ would be named unity\_0\_cxx.cxx, unity\_1\_cxx.cxx, and so on, while C files are named unity\_0\_c.c and so on. This variable is not intended to be set in CMakeLists.txt but rather to be passed over the command line or a preset, as it might depend on the context of whether a unity build is needed or not. CMake will decide on the language of the project if merging the files is needed and possible. For instance, as header files are not compiled, they will not be added to the unity sources. For C and C++, this works quite well; for other languages, this might not work.

Unity builds work best for projects that consist of many small files. If the source files are already large on their own, unity builds might run the risk of running out of memory when compiling. If only a few files are problematic in this regard, they can be excluded from the unity build by setting the SKIP\_UNITY\_BUILD\_INCLUSION property on the source files, like this:

\begin{lstlisting}[style=styleCMake]
target_sources(ch14_unity_build PRIVATE
	src/main.cpp
	src/fibonacci.cpp
	src/eratosthenes.cpp
)

set_source_files_properties(src/eratosthenes.cpp PROPERTIES
SKIP_UNITY_BUILD_INCLUSION YES)
\end{lstlisting}

In the example, the eratosthenes.cpp file would be excluded from the unity build, while main.cpp and fibonacci.cpp would be included in a single compilation unit. If the preceding project is configured, the unit\_0\_cxx.cxx file would contain something like this:

\begin{lstlisting}[style=styleCXX]
/* generated by CMake */

#include "/chapter_14/unity_build/src/main.cpp"
#include "/chapter_14/unity_build/src/fibonacci.cpp"
\end{lstlisting}

Note that the original source files are only included in the unity file, not copied into the file.

Since CMake 3.18, unity builds support two modes that are controlled with the CMAKE\_UNITY\_BUILD\_MODE variable or the UNITY\_BUILD\_MODE target property. The mode can either be BATCH or GROUP, with BATCH being the default if not specified. In the BATCH mode, CMake determines which files are grouped together by default, in the order in which they were added to the target. All files of a target will be assigned to batches unless they are explicitly excluded. In the GROUP mode, each target has to specify explicitly how the files are grouped together. Files not assigned to a group will be compiled individually. While group mode offers more precise control, using batch mode is often the preferred one, as it has significantly lower maintenance overhead.

By default, CMake will collect the files in batches of eight files when the UNITY\_BUILD\_MODE property is set to BATCH. By setting the UNITY\_BUILD\_BATCH\_SIZE property of a target, this can be changed. To set the batch size globally, the CMAKE\_UNITY\_BUILD\_BATCH\_SIZE cache variable is used. The batch size should be selected carefully, as setting it too low will bring little gain in performance, while setting it too high might cause the compiler to use too much memory or the compilation unit to hit other size constraints. If the batch size is set to 0, then all files of a target will be combined in a single batch, but this is discouraged because of the reasons mentioned earlier.

In group mode, no batch size is applied, but the files have to be assigned to groups by setting the UNITY\_GROUP property of the source file, as illustrated in the following example:

\begin{lstlisting}[style=styleCMake]
add_executable(ch14_unity_build_group)

target_sources(ch14_unity_build_group PRIVATE
	src/main.cpp
	src/fibonacci.cpp
	src/eratosthenes.cpp
	src/pythagoras.cpp
)
set_target_properties(ch14_unity_build_group PROPERTIES
	UNITY_BUILD_MODE GROUP)
set_source_files_properties(src/main.cpp src/fibonacci.cpp
	PROPERTIES UNITY_GROUP group1)
set_source_files_properties(src/erathostenes.cpp
	src/pythagoras.cpp PROPERTIES UNITY_GROUP group2)
\end{lstlisting}

In the example, the main.cpp and fibonacci.cpp files would be grouped together, and erathostenes.cpp and pythagoras.cpp would be compiled in a different group. In group mode, the generated files are named unity\_<groupName>\_<lang>.<lang>. So, in this example, the files would be named unity\_group1\_cxx.cxx and unity\_group2\_cxx.cxx.

Depending on the anatomy of a project, using unity builds can have a significant effect on build performance. Another technique often used to improve build times is using precompiled headers.

\subsubsubsection{14.4.2\hspace{0.2cm}Precompiled headers}

Precompiled headers are often a significant boost for the compile time, especially in cases where processing the headers is a significant part of the compile time or when header files are included in many different compilation units. In a nutshell, precompiled headers work by compiling some headers into a binary format that is easier to process for the compilers. Since CMake 3.16, direct support precompiled headers and most of the major compilers support some form of precompiled headers.

Precompiled headers are added to a target with the target\_precompile\_headers command, which has the following signature:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(<target>
	<INTERFACE|PUBLIC|PRIVATE> [header1...]
	[<INTERFACE|PUBLIC|PRIVATE> [header2...] ...])
\end{lstlisting}

The PRIVATE, PUBLIC, and INTERFACE keywords have the usual meaning. In the majority of the cases, PRIVATE should be used. The headers specified in the command will be collected in a cmake\_pch.h or cmake\_pch.hxx file in the build folder, which will be force-included in all source files by the respective compiler flag, so there is no need for the source files to have a \#include "cmake\_pch.h" directive.

The headers may be specified either as plain filenames, with angle brackets, or with double quotes, in which case they have to be escaped with double square brackets:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(SomeTarget PRIVATE myHeader.h
	[["external_header.h"]]
	  <unordered_map>
)
\end{lstlisting}

In this example, myHeader.h would be searched from the current source directory, while external\_header.h and unordered\_map are searched for in the include directories.

In large projects, precompiled headers that are used in multiple targets are relatively common. Instead of redefining them every time, the REUSE\_FROM option of target\_precompile\_headers can be used:

\begin{lstlisting}[style=styleCMake]
target_precompile_headers(<target> REUSE_FROM
	<other_target>)
\end{lstlisting}

Reusing precompiled headers will introduce an automatic dependency from target to other\_target. Both targets will have the same compiler options, flags, and definitions enabled. Some compilers will warn if this is not the case, but some might not.

Precompiled headers from another target may only be used if the current target does not define its own set of precompiled headers. If the target already has precompiled headers defined, CMake will halt with an error.

Precompiled headers are most effective in improving build times when the headers included rarely change. Any headers provided by the compiler, system, or external dependencies are generally good candidates to include in precompiled headers. Which headers exactly bring the most benefit is something that needs to be tried out and measured.

Together with unity builds, precompiled headers can improve compile time significantly, especially for projects with frequent header reuse. A third way to optimize build time for incremental builds is the use of compiler caches, namely ccache.

\subsubsubsection{14.4.3\hspace{0.2cm}Using a compiler cache (ccache) to speed up rebuilds}

Ccaches work by caching compilations and detecting when the same compilation is done again. At the time of writing this book, the most popular program for caching compile results is the ccache, which is open source and distributed under the LGPL 3. Ccache not only affects incremental builds but also fresh builds, as long as the cache is not deleted between the two runs. The cache created is portable between systems running the same compilers and can be stored in remote databases, so multiple developers may access the same cache. Officially, ccache supports GCC, Clang, and NVCC but people claim to have run it for MSVC and Intel compilers. When using ccache with CMake, it works best with Makefile and Ninja generators. At the time of writing this book, Visual Studio was not supported.

To use ccache with CMake, the CMAKE\_<LANG>\_COMPILER\_LAUNCHER cache variable is used, where <LANG> is replaced with the respective programming language. The recommended way is to pass this in using a preset, but to enable ccache for C and C++ inside CMakeLists.txt, the following code can be used:

\begin{lstlisting}[style=styleCMake]
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
	set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM})
	set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM})
endif()
\end{lstlisting}

Passing the variable from a preset or from the command line is also a good alternative, especially because the configuration of ccache is done easiest by using environment variables.

Using ccache with the default configuration might already bring a considerable improvement regarding build times, but if the build is a bit more complex, further configuration might be necessary. To configure ccache, certain environment variables starting with CCACHE\_ can be used; for full documentation of all the configuration options refer to the ccache documentation. Common scenarios that need special attention are combining ccache with precompiled headers, managing dependencies that are included using FetchContent, and combining ccache with other compiler wrappers, such as distcc or icecc for distributed builds. For these scenarios, the following environment variables are used:

\begin{itemize}
\item 
To work efficiently with precompiled headers, set CCACHE\_SLOPPINESS to pch\_defines,time\_macros. The reason for this is that ccache cannot detect changes in \#defines in the precompiled header and it cannot tell whether \_\_TIME\_\_, \_\_DATE\_\_, or \_\_TIMESTAMP\_\_ is used when creating precompiled headers. Optionally, include\_file\_mtime to CCACHE\_SLOPPINESS might further increase the cache hit performance, but it carries a very small risk of a race condition.

\item 
When including big dependencies that are built from source, for instance, by using FetchContent, setting CCACHE\_BASEDIR to CMAKE\_BINARY\_DIR might increase the cache hit rate; this might bring a performance boost especially if there are many (sub)projects fetching the same dependency. On the other hand, if the sources in the project itself are the ones that take more time to compile, setting this to CMAKE\_SOURCE\_DIR might bring better results. It needs to be tried out to learn which one brings the better result.

\item 
To work with other compiler wrappers, the CCACHE\_PREFIX environment variable is used to add the commands for the other compiler wrapper. It is recommended to use ccache first when chaining multiple wrappers so the result of the other wrappers may also be cached.
\end{itemize}

Passing the environment variables to CMake using a configure preset, as described in Chapter 9, Creating Reproducible Build Environments, is the recommended way; this can either be combined with detecting ccache inside the CMakeLists.txt, or the ccache command may also be passed using the following preset:

\begin{lstlisting}[style=styleCMake]
{
	"name" : "ccache-env",
	...
	"environment": {
		"CCACHE_BASEDIR" : "${sourceDir}",
		"CCACHE_SLOPPINESS" : "pch_defines,time_macros"
	}
},
\end{lstlisting}

With these configurations, using ccache can yield very large benefits to the compile time, but caching compiler results is a complicated matter, so to get the full benefit, the ccache documentation should be consulted. In most cases, using ccache will probably bring the most performance benefit with a relatively trivial setup. Other tools, such as distcc for distributed builds, work very similarly from the CMake perspective, but require a bit more setup work.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Distributed builds}

Distributed builds work by shoveling off some part of the compilation to different machines on a network. This requires setting up the servers that can accept connections and then configuring the clients to be able to connect to these servers. Setting up a server for distcc happens with the following command:

\begin{tcblisting}{commandshell={}}
distccd --daemon --allow client1 client2
\end{tcblisting}

Here, client1 and client2 are the hostnames or IP addresses of the respective build servers. On the client side, configuring CMake to use distcc will work similarly to using ccache by setting CMAKE\_<LANG>\_COMPILER\_LAUNCHER to the distcc command. The list of potential servers is either configured over a configuration file or by the DISTCC\_HOSTS environment variable. Unlike the ccache configuration, this is very host-specific, so the configuration should be put into a user preset, not the project-specific preset. The respective preset might look like this:

\begin{lstlisting}[style=styleCMake]
{
	"name" : "distcc-env",
	...
	"environment": {
		"DISTCC_HOSTS" : "localhost buildsrvr1,cpp,lzo
		host123,cpp,lzo"
	}
},
\end{lstlisting}

Note the cpp postfix after the buildsrvr1 host. This puts distcc into so-called pump mode, which further increases compilation speed by also distributing the preprocessing to the servers. The lzo postfix tells distcc to compress the communication.

The downside to distributed builds is that in order to gain a speed benefit, the network has to be fast enough or else the cost of transferring the information for compiling might be higher than the reduced build time. However, in most local networks, this is easily the case. Distributed builds work well if the machines are similar regarding processor architecture, compilers, and operating systems. While cross-compiling using distcc is possible, it can be quite a bit of work to set up. By combining good coding practices, precompiled headers and compiler caches working on large projects still work without waiting minutes for every single build.










