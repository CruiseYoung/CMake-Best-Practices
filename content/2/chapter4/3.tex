
In the previous section, we learned how to make our project installable so that others can consume our project by installing it on their system. But sometimes, delivering the artifacts is not enough. For example, if you are delivering a library, it must also be easy to import it into a project – especially a CMake project. In this section, we will learn how to make this importing process easier for other CMake projects.

There are convenient ways of importing a library, given that the project to be imported has the proper configuration files. One of the prominent ways of doing so is by utilizing the find\_package() method (which we will cover in Chapter 5, Integrating Third-Party Libraries and Dependency Management). If you have consumers that are using CMake in their workflows, they will be happy if they can just write find\_package(your\_project\_name) and start using your code. In this section, we will learn how to generate the required configuration files to make find\_package() work for your project.

CMake's preferred way of consuming dependencies is via packages. Packages convey dependency information for CMake-based build systems. Packages can be in the form of Config-file packages, Find-module packages, or pkg-config packages. All of the package types can be found and consumed via find\_package(). For the sake of space and simplicity, we will only be covering Config-file packages in this section. The rest of the ways are mostly workarounds for lack of config files, so they are better left in the past. Let's start discovering the Config-file packages.

\subsubsubsection{4.3.1\hspace{0.2cm}Entering the CMake package world – Config-file packages}

Config-file packages are based on configuration files that contain package content information. This information indicates the package's content locations, so CMake reads this file and uses the package. Thus, discovering only the package configuration files is enough to consume the package.

There are two types of configuration files – a package configuration file and an optional package version file. Both files must have a specific naming convention. Package configuration files can be named <ProjectName>Config.cmake or <projectname>-config.cmake, depending on personal preference. Both notations will be picked by CMake on find\_package(ProjectName)/find\_package(projectname) calls. The content of package configuration files looks similar to the following:

\begin{lstlisting}[style=styleCMake]
set(Foo_INCLUDE_DIRS ${PREFIX}/include/foo-1.2)
set(Foo_LIBRARIES ${PREFIX}/lib/foo-1.2/libfoo.a)
\end{lstlisting}

Here, \$\{PREFIX\} is the installation prefix of the project. It is a variable since the installation prefix can be changed based on the system's type and can also be changed by the user.

Similar to package configuration files, package version files can be named <ProjectName>ConfigVersion.cmake or <projectname>-config-version. cmake as well. CMake expects package configuration and package version files to be present in the find\_package(...) search paths. You can create these files with the help of CMake. One of the many places that find\_package(...) looks while searching for packages is the <CMAKE\_PREFIX\_PATH>/cmake directory. We'll be putting our Config-file package configuration files into this folder throughout our examples.

To create config-file packages, we will need to learn a few extra things, such as exporting targets and the CmakePackageConfigHelpers module. To learn about these things, let's start diving into an actual example. We'll be following Chapter 4, Example 5 to learn how to structure a CMake project to make it a config-file package. It is located in the chapter4/ex05\_config\_file\_package folder. Let's start by inspecting the CMakeLists.txt file in the chapter4/ex05\_config\_file\_package directory (comments and project commands have been omitted in favor of space; also, note that the lines that are not relevant to the topic will not be mentioned):

\begin{lstlisting}[style=styleCMake]
include(GNUInstallDirs)
set(ch4_ex05_lib_INSTALL_CMAKEDIR cmake CACHE PATH
"Installation directory for config-file package cmake files")
/*…*/
\end{lstlisting}

The CMakeLists.txt file is quite similar to chapter4/ex02\_static. This is because it is the same example, except it supports the config-file packaging. The first line, include(GNUInstallDirs), is used to include the GNUInstallDirs module. This provides the CMAKE\_INSTALL\_INCLUDEDIR variable, which will be used later. set(ch4\_ex05\_lib\_INSTALL\_CMAKEDIR...) is a user-defined variable for setting the target installation directory of the config-file packaging configuration files. It is a relative path that should be used in the install(…) directives, so it is implicitly relative to CMAKE\_INSTALL\_PREFIX:

\begin{lstlisting}[style=styleCMake]
/*…*/
target_include_directories(ch4_ex05_lib PUBLIC
	$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
)
target_compile_features(ch4_ex05_lib PUBLIC cxx_std_11)
/*…*/
\end{lstlisting}

The target\_include\_directories(...) call is quite different than the usual calls. It uses generator expressions to distinguish between build-time include directories and install-time include directories since the build-time include path will not be present when the target is imported into another project. The following set of commands will make the target installable:

\begin{lstlisting}[style=styleCMake]
/*…*/
install(TARGETS ch4_ex05_lib
	EXPORT ch4_ex05_lib_export
	INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
install (
	DIRECTORY ${PROJECT_SOURCE_DIR}/include/
	DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
/*…*/
\end{lstlisting}

install(TARGETS...) is a bit different than usual as well. It contains an extra EXPORT parameter. This EXPORT parameter is used to create an export name from the given install(…) targets. These targets can then be exported using this export name. The path that's specified with the INCLUDES DESTINATION parameter will be used to populate the INTERFACE\_INCLUDE\_DIRECTORIES property of the exported target and will be automatically prefixed with the install prefix path. Here, the install(DIRECTORY...) command is used to install the target's header files and is located in \$\{PROJECT\_SOURCE\_DIR\}/include/, in the \$\{CMAKE\_INSTALL\_PREFIX\}/\$\{CMAKE\_INSTALL\_INCLUDEDIR\} directory. The \$\{CMAKE\_INSTALL\_INCLUDEDIR\} variable is used to give consumers the ability to override the include directory for this installation. Now, let's create an export file from the export name we created in the preceding example:

\begin{lstlisting}[style=styleCMake]
/*…*/
install(EXPORT ch4_ex05_lib_export
	FILE ch4_ex05_lib-config.cmake
	NAMESPACE ch4_ex05_lib::
	DESTINATION ${ch4_ex05_lib_INSTALL_CMAKEDIR}
)
/*…*/
\end{lstlisting}

install(EXPORT...) is perhaps the most important piece of code in this file. It is the code that is doing the actual target exporting. It generates a CMake file that contains all the exported targets in the given export name. The EXPORT parameter accepts an existing export name to perform the export. It is referring to the ch4\_ex05\_lib\_export export name that we created by the previous install(TARGETS...) call. The FILE parameter is used to determine the export's filename and is set to ch4\_ex05\_lib-config.cmake. The NAMESPACE parameter is used to prefix all the exported targets with a namespace. This allows you to connect all the exported targets under a common namespace and avoid collisions with packages that have similar target names. Lastly, the DESTINATION parameter determines the installation path of the generated export file. This is set to \$\{ch4\_ex05\_lib\_INSTALL\_CMAKEDIR\} to allow find\_package() to discover it.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black,title=Note]
Since we are not providing any extras other than exported targets, the name of the export file is ch4\_ex05\_lib-config.cmake. It is the package configuration file name that's required for this package. We've done this because the example project does not require any extra dependencies to be satisfied first and can be directly imported as-is. If any extra action is required, it is recommended to have an intermediate package configuration file that satisfies those dependencies and includes the exported file after.
\end{tcolorbox}

With the install(EXPORT...) command, we obtained the ch4\_ex05\_lib-config.cmake file. This means that our target can be consumed via find\_package(..). One additional step is required to achieve full support for find\_package(…), which is obtaining the ch4\_ex05\_lib-config-version.cmake file:

\begin{lstlisting}[style=styleCMake]
/*…*/
include(CMakePackageConfigHelpers)
write_basic_package_version_file(
	"ch4_ex05_lib-config-version.cmake"
	# Package compatibility strategy. SameMajorVersion is
	essentially 'semantic versioning'.
	COMPATIBILITY SameMajorVersion
)
install(FILES
	"${CMAKE_CURRENT_BINARY_DIR}/ch4_ex05_lib-config-version.
	cmake"
	DESTINATION "${ch4_ex05_lib_INSTALL_CMAKEDIR}"
)
/* end of the file */
\end{lstlisting}

In the last few lines, you can find the code that's required to generate and install the ch4\_ex05\_lib-config-version.cmake file. With the include(CMakePackageConfigHelpers) line, the CMakePackageConfigHelpers module is imported. This module provides the write\_basic\_package\_version\_file(…) function. write\_basic\_package\_version\_file(…) is used to automatically generate package version files, depending on the given parameters. The first positional argument is the output's filename. The VERSION parameter is used to specify the version of the package we're generating in major.minor.patch form. It is opted out to allow write\_basic\_package\_version\_file to get it from the project version automatically. The COMPATIBILITY parameter allows you to specify compatibility policies, depending on the version's value. SameMajorVersion denotes that this package is compatible with any version that has the same major version value of this package. The other possible values are AnyNewerVersion, SameMinorVersion, and ExactVersion.

Now, let's test whether this works. To test the package configuration, we must install the project regularly:

\begin{tcblisting}{commandshell={}}
cmake –S . -B ./build
cmake --build ./build
cmake --install ./build --prefix /tmp/install-test
\end{tcblisting}

The cmake -{}-install command's output should look as follows:

\begin{tcblisting}{commandshell={}}
/* … */
-- Installing: /tmp/install-test/cmake/ch4_ex05_lib-config.cmake
-- Installing: /tmp/install-test/cmake/ch4_ex05_lib-confignoconfig.
cmake
-- Installing: /tmp/install-test/cmake/ch4_ex05_lib-configversion.
cmake
/*…*/
\end{tcblisting}

Here, we can see that our package configuration files have been successfully installed in the /tmp/install-test/cmake directory. I'll leave inspecting the content of those files to you as an exercise. So, we have a consumable package in our hands. Let's switch sides and try to consume our freshly baked package. To do that, we'll look at the chapter4/ex05\_consumer example. Let's inspect the CMakeLists.txt file together:

\begin{lstlisting}[style=styleCMake]
if(NOT PROJECT_IS_TOP_LEVEL)
	message(FATAL_ERROR "The chapter-4, ex05_consumer project is
		intended to be a standalone, top-level project. Do not
			include this directory.")
endif()
find_package(ch4_ex05_lib 1 CONFIG REQUIRED)
add_executable(ch4_ex05_consumer src/main.cpp)
target_compile_features(ch4_ex05_consumer PRIVATE cxx_std_11)
target_link_libraries(ch4_ex05_consumer ch4_ex05_lib::ch4_ex05_
	lib)
\end{lstlisting}

In the first few lines, we can see verification regarding whether the project is a top-level project or not. Since this example is intended to be an external application, it should not be part of the root example project. Thus, we can guarantee that we will use the targets that are exported by the package, not the root project's targets. The root project also does not include the ex05\_consumer folder. Next, there's a find\_package(…) call, where ch4\_ex05\_lib is given as a package name. It is also explicitly requested that the package should have a major version of 1; find\_package(…) must only consider CONFIG packages and packages specified in this find\_package(…) call are required. In the consequent lines, a regular executable is defined called ch4\_ex05\_consumer that's linked against ch4\_ex05\_lib in the ch4\_ex05\_lib namespace (ch4\_ex05\_lib::ch4\_ex05\_lib). ch4\_ex05\_lib::ch4\_ex05\_lib is the actual target we have defined in our package. Let's look at the source file, src/main.cpp:

\begin{lstlisting}[style=styleCXX]
#include <chapter4/ex05/lib.hpp>
int main(void){
	chapter4::ex05::greeter g;
	g.greet();
}
\end{lstlisting}

This is a simple application that includes chapter4/ex05/lib.hpp, creates an instance of the greeter class, and calls the greet() function. Let's try to compile and run the application:

\begin{tcblisting}{commandshell={}}
cd chapter_4/ex05_consumer
cmake -S . -B build/ -DCMAKE_PREFIX_PATH:STRING=/tmp/install-test
cmake --build build/
./build/ch4_ex05_consumer
\end{tcblisting}

Since we have installed the package using a custom prefix (/tmp/install-test), we can indicate this by setting the CMAKE\_PREFIX\_PATH variable. This causes find\_package(…) to search /tmp/install-test for packages as well. For default prefix installations, this parameter setting is not required. We should see the infamous Hello, world! message if everything goes well: 

\begin{tcblisting}{commandshell={}}
./build/ch4_ex05_consumer
Hello, world!
\end{tcblisting}

Here, our consumers can use our little greeter and everybody is happy. Now, let's conclude this section by learning how to package with CPack.



























