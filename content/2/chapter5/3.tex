
若正在认真地编写软件，那么你的项目迟早会依赖于项目外部的库。而不是寻找单独的库文件或头文件，CMake社区和本书作者推荐的方法是使用\texttt{find\_package}，在CMake中查找依赖项的首选方法是使用包。

包提供了一组关于CMake和生成构建系统依赖关系的信息，可以以两种形式集成到项目中。可以通过上游项目提供的配置细节(也称为配置文件包)来实现，也可以通过所谓的查找模块包来实现，查找模块包通常定义在与包无关的地方，由CMake本身或使用包的项目来实现。这两种类型都可以通过使用\texttt{find\_package}找到，结果是一组导入的目标和/或一组变量，其中包含与构建系统相关的信息。

findPkgConfig模块使用find-pkg查找依赖项的相关元信息，还间接支持包的方式。

通常，find模块用于定位依赖项，例如：上游没有为包配置提供必要的信息时。不要将它们与CMake实用程序模块混淆，后者与\texttt{include()}一起使用。只要可能，就应该使用上游提供的包而不是find模块，修复上游项目以提供必要的信息要优于编写find模块。

注意，\texttt{find\_package}有两个签名:基本签名或短签名，一个完整签名或长签名。所有场景中，使用短签名就足以找到正在寻找的包，因为它更容易维护，应该是首选。短格式同时支持模块和配置包，而长格式只支持配置模式。

短模式的签名如下:

\begin{lstlisting}[style=styleCMake]
find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE]
	[REQUIRED] [[COMPONENTS] [components...]]
	[OPTIONAL_COMPONENTS components...]
	[NO_POLICY_SCOPE])
\end{lstlisting}

假设想要编写一个程序，通过OpenSSL库的适当功能将字符串转换为sha256散列码。为了编译和链接这个示例，必须通知CMake该项目需要OpenSSL库，然后将其附加到目标中。现在，假设必要的库已经安装在系统上的默认位置;例如：Linux使用apt、RPM或类似的包管理器，Windows使用chocoley，macOS使用brew。

一个CMakeLists.txt文件可能是这样的:

\begin{lstlisting}[style=styleCMake]
find_package(OpenSSL REQUIRED COMPONENTS SSL)
add_executable(find_package_example)
target_link_libraries(find_package_example PRIVATE
	OpenSSL::SSL)
\end{lstlisting}

上面的例子做了以下事情:

\begin{enumerate}
\item 
第一行\texttt{find\_package(OpenSSL REQUIRED COMPONENTS SSL)}，这表明正在为OpenSSL寻找一组库和头文件。具体来说，正在寻找SSL组件，而忽略加密组件。REQUIRED关键字说明必须使用其来构建这个项目，若没有找到库，CMake将停止配置过程，并出现错误。

\item 
找到包后，告诉CMake使用\texttt{target\_link\_library}将库链接到目标，告诉CMake链接OpenSSL包提供的OpenSSL::SSL目标。
\end{enumerate}

If a dependency has to be of a certain version, it can be specified either as a single version of the major[.minor[.patch[.tweak]]] format or as a version range with the versionMin..[<]versionMax format. For version ranges, both versionMin and versionMax should have the same format, and by specifying <, the upper version will be excluded.

若依赖指定了版本，则可以将其指定为major[.minor[.patch[.tweak]]]，或使用versionMin..[<]versionMax的方式作为版本划定范围。对于版本范围，versionMin和versionMax应该具有相同的格式，通过指定小于号，将排除versionMax。

但从3.21版本起，CMake无法查询可用组件的模块。因此，必须依赖模块或库提供者的文档，找出哪些组件是可用的。可用的模块可以通过以下命令查询:

\begin{tcblisting}{commandshell={}}
cmake --help-module-list #< lists all available modules
cmake --help-module <mod> #< prints the documentation for
  module
  <mod>
cmake --help-modules #< lists all modules and their
  documentation
\end{tcblisting}

可以在以下网站找到CMake附带的模块列表\url{https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html}。

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=查找单个库和文件]
可以查找单独的库和文件，但首选的方法是包。查找单独的文件，将它们提供给CMake将在编写查找模块的章节中介绍。
\end{tcolorbox}

在模块模式下运行时，\texttt{find\_package}会搜索名为Find<PackageName>.cmake的文件;首先会在CMAKE\_MODULE\_PATH指定的路径中搜索，然后是在CMAKE安装提供的查找模块中。弱想学习如何创建CMake包，请阅读第4章的相关内容。

在配置模式下运行时，\texttt{find\_package}会搜索以下的文件:

\begin{itemize}
\item 
<lowercasePackageName>-config.cmake

\item 
<PackageName>Config.cmake

\item 
<lowercasePackageName>-config-version.cmake (若指定了版本详细信息)

\item 
<PackageName>ConfigVersion.cmake (若指定了版本详细信息)
\end{itemize}

所有的搜索将按照明确的顺序进行;若需要，可以通过将相应的选项传递给CMake来跳过一些位置。\texttt{find\_package}比其他\texttt{find\_}指令包含更多的选项。下表展示了搜索顺序:

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{位置}                     & \textbf{跳过命令中的选项}  \\ \hline
		包的根变量                & NO\_PACKAGE\_ROOT\_PATH              \\ \hline
		特定于CMake的缓存变量        & NO\_CMAKE\_PATH                      \\ \hline
		特定于CMake的环境变量  & NO\_CMAKE\_ENVIRONMENT\_PATH         \\ \hline
		HINTS选项中指定的路径  &                                      \\ \hline
		系统环境变量 & NO\_SYSTEM\_ENVIRONMENT\_PATH        \\ \hline
		用户包的注册表                 & NO\_CMAKE\_PACKAGE\_REGISTRY         \\ \hline
		特定于系统的缓存变量       & NO\_CMAKE\_SYSTEM\_PATH              \\ \hline
		系统包的注册表               & NO\_CMAKE\_SYSTEM\_PACKAGE\_REGISTRY \\ \hline
		PATHS选项中指定的路径   &                                      \\ \hline
	\end{tabular}
\end{table}

更仔细地了解一下搜索顺序和搜索位置:

\begin{itemize}
\item 
包的根变量:每个\texttt{find\_package}包的根变量存储在名为<PackageName>\_ROOT中，是搜索属于包的文件的第一处搜索的地方。包的根变量与CMAKE\_PREFIX\_PATH相同，不仅用于\texttt{find\_package}，而且用于可能发生在属于包的find模块内部的其他\texttt{find\_}指令。

\item 
特定于CMake的缓存变量:是从CMAKE\_PREFIX\_PATH派生的位置。对于macOS, CMAKE\_FRAMEWORK\_PATH变量也认为是一个搜索位置。

\item 
通过设置CMAKE\_FIND\_USE\_CMAKE\_PATH变量为false，将跳过CMAKE特定缓存变量的位置。

\item 
特定于CMake的环境变量:除了指定CMAKE\_PREFIX\_PATH和CMAKE\_FRAMEWORK\_PATH作为缓存变量外，若设置为环境变量，CMAKE也会考虑搜索它们。

\item 
将CMAKE\_FIND\_USE\_ENVIRONMENT\_PATH设置为false将禁用此行为。

\item 
find\_package的HINTS :这些是传递给\texttt{find\_package}的可选路径。

\item 
特定于系统的环境变量:PATH环境变量用于查找包和文件，并删除尾随的bin和sbin目录。每个系统的默认位置，例如/usr、/lib和类似的位置。

\item 
用户包的注册表:通常，包要么在标准位置中找到，要么在通过CMAKE\_PREFIX\_PATH选项传递给CMake的位置中找到。包注册表是告诉CMake在哪里查找依赖项的另一种方法。用户注册表对当前用户帐户有效，而系统包注册表在系统范围内有效。在Windows上，用户包的注册表位置存储在下面位置:

\item 
HKEY\_CURRENT\_USER\verb|\|Software\verb|\|Kitware\verb|\|CMake\verb|\|Packages\verb|\|<packageName>\

\item 
在Unix平台上，存储在用户的主目录中:~/.cmake/packages/<PackageName>

\item 
特定于平台的缓存变量:对于\texttt{find\_package}，特定于平台的缓存变量CMAKE\_SYSTEM\_PREFIX\_PATH, CMAKE\_SYSTEM\_FRAMEWORK\_PATH和CMAKE\_SYSTEM\_APPBUNDLE\_PATH的工作方式与其他\texttt{find}类似。它们是由CMake自己设置的，不应该由项目更改。

\item 
系统包的注册表:与用户包注册表类似，这是CMake查找包的位置。在Windows上，存储在 HKEY\_LOCAL\_MACHINE\verb|\|Software\verb|\|itware\verb|\|CMake\verb|\|Packages\verb|\|<packageName>\verb|\|。

\item 
Unix系统不提供系统包的注册表。

\item 
来自\texttt{find\_package}的路径:是传递给\texttt{find\_package}的可选路径。通常，HINTS选项是从其他值计算出来的，或者依赖于变量，而PATHS选项是固定路径。
\end{itemize}

具体来说，当在配置模式下查找包时，CMake将在各种前缀下查找以下文件结构:

\begin{lstlisting}[style=styleCMake]
<prefix>/
<prefix>/(cmake|CMake)/
<prefix>/<packageName>*/
<prefix>/<packageName>*/(cmake|CMake)/
<prefix>/(lib/<arch>|lib*|share)/cmake/<packageName>*/
<prefix>/(lib/<arch>|lib*|share)/<packageName>*/
<prefix>/(lib/<arch>|lib*|share)/<packageName>*/(cmake|CMake)/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/cmake/
  <packageName>*/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/<packageName>*/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/<packageName>*/
  (cmake|CMake)/
\end{lstlisting}

macOS平台上，还搜索以下文件夹:

\begin{lstlisting}[style=styleCMake]
<prefix>/<packageName>.framework/Resources/
<prefix>/<packageName>.framework/Resources/CMake/
<prefix>/<packageName>.framework/Versions/*/Resources/
<prefix>/<packageName>.framework/Versions/*/Resources/CMake/
<prefix>/<packageName>.app/Contents/Resources/
<prefix>/<packageName>.app/Contents/Resources/CMake/
\end{lstlisting}

可以在官方的CMake文档中找到更多关于包的信息\url{https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html}。

就模块而言，我们只讨论了如何查找现有的模块。但若想要寻找既没有集成到CMake中，也没有在标准位置中，或者没有为CMake提供配置说明的依赖项，会发生什么呢?让我们在下一节中寻找答案吧。

\subsubsubsection{5.3.1\hspace{0.2cm}编写查找模块}

While CMake is almost an industry standard, there are still lots of libraries out there that are not managed with CMake or that are managed with CMake but do not export a CMake package. If they can be installed in the default location of a system, finding these libraries is usually not a problem, but this is not always possible or wanted. A common case is when using a proprietary third-party library that is only needed for a certain project or that uses a different version of a library to build from the one that is installed by the systems package manager.

If you're developing multiple projects side by side, you might want to handle the dependencies locally for each project. Either way, it is good practice to set up your project in a way so that dependencies are managed locally and do not depend too much on what is installed on the system. Creating fully reproducible builds is described in Chapter 11, Automated Fuzzing with CMake; however, for now, let's focus on finding dependencies. 

If no module and no configuration file exists for a dependency, often, writing your so-called find module is the solution. The goal is to provide enough information so that, later, we can use any package by using find\_package.

Find modules are instructions for CMake on how to find the necessary header and binary files for a library and which create imported targets for CMake to use. As described earlier in this chapter, when invoking find\_package in module mode, CMake searches for files called Find<PackageName>.cmake in CMAKE\_MODULE\_PATH.

Let's assume that we're building a project where the dependencies have already been downloaded or built and have been placed in a folder called dep before we use them. So, the project structure might look like this:

\begin{tcblisting}{commandshell={}}
├── dep <-- The folder where we locally keep dependencies
├── cmake
│       └── FindLibImagePipeline.cmake <-- This is what we need to write
├── CMakeLists.txt <-- Main CmakeLists.txt
├── src
│       ├── *.cpp files
\end{tcblisting}

The first thing we have to do is to add the cmake folder to the CMAKE\_MODULE\_PATH, which is a list. So, first, we add the following line to the CMakeLists.txt file:

\begin{lstlisting}[style=styleCMake]
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
\end{lstlisting}

This tells CMake that it should look for find modules in the cmake folder. Typically, a find module does things in the following order:

\begin{enumerate}
\item 
It looks for files belonging to the package.
	
\item 
It sets up variables containing the include and library directories for the packages.

\item 
It sets up targets for the imported package.

\item 
It sets properties for the targets.
\end{enumerate}

A simple FindModules.cmake for a library called obscure might look like this:

\begin{lstlisting}[style=styleCMake]
cmake_minimum_required(VERSION 3.21)
find_library(
	OBSCURE_LIBRARY
	NAMES obscure
	HINTS ${PROJECT_SOURCE_DIR}/dep/
	PATH_SUFFIXES lib bin build/Release build/Debug
)

find_path(
	OBSCURE_INCLUDE_DIR
	NAMES obscure/obscure.hpp
	HINTS ${PROJECT_SOURCE_DIR}/dep/include/
)

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(
	Obscure
	DEFAULT_MSG
	OBSCURE_LIBRARY
	OBSCURE_INCLUDE_DIR
)

mark_as_advanced(OBSCURE_LIBRARY OBSCURE_INCLUDE_DIR)

if(NOT TARGET Obscure::Obscure)
	add_library(Obscure::Obscure UNKNOWN IMPORTED )
	set_target_properties(Obscure::Obscure PROPERTIES
		IMPORTED_LOCATION "${OBSCURE_LIBRARY}"
		INTERFACE_INCLUDE_DIRECTORIES
			"${OBSCURE_INCLUDE_DIR}"
		IMPORTED_LINK_INTERFACE_LANGUAGES "CXX"
	)
endif()
\end{lstlisting}

When looking at the example, we can observe that the following things happen:

\begin{enumerate}
\item 
First, the actual library file belonging to the dependency is searched for using the find\_library command. If found, the path to it, including the actual filename, is stored in the OBSCURE\_LIBRARY variable. It is a common practice to name the <PACKAGENAME>\_LIBRARY variable. The NAMES argument is a list of possible names for the library. The names are automatically extended with common prefixes and extensions. So, although, in the preceding example, we look for the name "obscure," a file named libobscure.so or obscure.dll will be found. More details about the search order, hints, and paths will be covered later in this section.

\item 
Next, the Find module attempts to locate the include path. This is done by finding a known path pattern of the library, usually one of the public header files. The result is stored in the OBSCURE\_INCLUDE\_DIR variable. Again, the common practice is to name this variable as <PACKAGENAME>\_INCLUDE\_DIR.

\item 
Since handling all the requirements for a find module can be tedious and is often very repetitive, CMake provides the FindPackageHandleStandardArgs module, which provides a handy function to handle all the common cases. It provides the find\_package\_handle\_standard\_args function, which handles REQUIRED, QUIET, and the version-related arguments of find\_package. find\_package\_handle\_standard\_args has a short signature and a long signature. In the example, the short signature is used:

\begin{lstlisting}[style=styleCMake]
find_package_handle_standard_args(<PackageName>
	(DEFAULT_MSG|<custom-failure-message>)
	<required-var>...
	)
\end{lstlisting}

\item 
For most cases, the short form of find\_package\_handle\_standard\_args is sufficient. In the short form, the find\_package\_handle\_standard\_args function takes the package name as the first argument and a list of variables that are required for the package. The DEFAULT\_MSG argument tells it to print default messages in the event of success or failure, depending on whether find\_package was invoked with REQUIRED or QUIET. The message can be customized, but we recommend that you stick to the default messages whenever possible. That way, the messages are consistent for all the find\_package commands. In the preceding example, find\_package\_handle\_standard\_args checks whether the OBSCURE\_LIBRARY and OBSCURE\_INCLUDE\_DIR variables that have been passed are valid. If that is the case, the <PACKAGENAME>\_FOUND variable is set.

\item 
If all goes well, the find module defines the target. Before we do this, it is helpful to check whether the target we are trying to create does not already exist (to avoid overwriting it in the case that we have multiple calls to find\_package for the same dependency). Creating the target is done with add\_library. Since we cannot be sure whether it is a static or dynamic library, the type is UNKNOWN and the IMPORTED flag is set.

\item 
Finally, the properties for the library are set. The minimum setting that we recommend is the MPORTED\_LOCATION property and the location of the include files in INTERFACE\_INCLUDE\_DIR.
\end{enumerate}

If everything works as expected, the library can then be used like this:

\begin{lstlisting}[style=styleCMake]
find_package(Obscure PRIVATE REQUIRED)
...
target_link_libraries(find_module_example Obscure::Obscure)
\end{lstlisting}

So, now we understand how other libraries are added to your projects if they are already available for use. But how do we get the libraries into our system in the first place? Let's find that out in the next section.

