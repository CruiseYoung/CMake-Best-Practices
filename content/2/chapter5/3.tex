
If you're writing software in earnest, sooner or later, you will hit the point where your project will rely on libraries from outside your project. Instead of looking for individual library files or header files, the recommended way by the CMake community and us authors is to do this with the find\_package command. The preferred approach for finding dependencies in CMake is using packages.

Packages provide a set of information about dependencies for CMake and the generated build systems. They can be integrated into a project in two forms. This is either by their configuration details (also called config-file packages), which are provided by the upstream project, or as so-called find module packages, which are usually defined somewhere that is unrelated to the package, either by CMake itself or by the project using the package. Both types can be found by using find\_package, and the result is a set of imported targets and/or a set of variables containing information that is relevant to the build system.

The findPkgConfig module, which uses find-pkg to find the relevant metainformation for a dependency, also provides indirect support for packages.

Typically, Find modules are used for locating dependencies, for instance, when the upstream does not provide the necessary information for package configuration. They are not to be confused with CMake utility modules, which are used with include(). Whenever possible, using a package provided by the upstream should be used instead of the find modules. If possible, fixing the upstream project to provide the necessary information is preferred over writing a find module.

Note that the find\_package command has two signatures: a basic or short signature and a full or long signature. In almost all scenarios, using the short signature is sufficient to find the packages we're looking for, and it should be preferred because it is easier to maintain. The short form supports both the module and config packages, but the long form only supports configuration mode.

The signature of the short mode is as follows:

\begin{lstlisting}[style=styleCMake]
find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE]
	[REQUIRED] [[COMPONENTS] [components...]]
	[OPTIONAL_COMPONENTS components...]
	[NO_POLICY_SCOPE])
\end{lstlisting}

Let's suppose we want to write a program that converts a string into a sha256 hash by using the appropriate functionality of the OpenSSL library. To compile and link this example, we have to inform CMake that this project needs the OpenSSL library and then attach it to the target. For the moment, let's assume that the necessary libraries have been installed at a default location on your system; for example, by using a regular package manager such as apt, RPM, or similar for Linux, chocolatey for Windows, or brew for macOS.

A sample CMakeLists.txt file might look like this:

\begin{lstlisting}[style=styleCMake]
find_package(OpenSSL REQUIRED COMPONENTS SSL)
add_executable(find_package_example)
target_link_libraries(find_package_example PRIVATE
	OpenSSL::SSL)
\end{lstlisting}

The preceding example does the following things:

\begin{enumerate}
\item 
On the first line in the example, there is a find\_package(OpenSSL REQUIRED COMPONENTS SSL) call. This tells CMake that we're looking for a set of libraries and header files for OpenSSL. Specifically, we're looking for the SSL component and ignoring the crypto component. The REQUIRED keyword tells CMake that it is required to build this project. This means that CMake will stop the configuration process with an error if the library is not found.

\item 
Once the package has been found, we tell CMake to link the library to the target using target\_link\_libary. Specifically, we tell CMake to link the OpenSSL::SSL target provided by the package OpenSSL.
\end{enumerate}

If a dependency has to be of a certain version, it can be specified either as a single version of the major[.minor[.patch[.tweak]]] format or as a version range with the versionMin..[<]versionMax format. For version ranges, both versionMin and versionMax should have the same format, and by specifying <, the upper version will be excluded.

Unfortunately, as of version 3.21, CMake cannot query the modules for the available components. So, we have to rely on the documentation of the modules or library providers to find out which components are available. The available modules can be queried with the following commands:

\begin{tcblisting}{commandshell={}}
cmake --help-module-list #< lists all available modules
cmake --help-module <mod> #< prints the documentation for
  module
  <mod>
cmake --help-modules #< lists all modules and their
  documentation
\end{tcblisting}

A list of modules shipped with CMake can be found at \url{https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html}.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=查找单个库和文件]
It is possible to look for individual libraries and files, but the preferred way is to use packages. Finding individual files and making them available to CMake will be covered in the Writing your own find module section.
\end{tcolorbox}

When run in module mode, the find\_package command searches for files called Find<PackageName>.cmake; this occurs, first, in the paths specified by CMAKE\_MODULE\_PATH and then among the find modules provided by the CMake installation. If you wish to learn how to create CMake packages, head over to Chapter 4, Packaging, Deploying, and Installing a CMake Project.

When run in config mode, find\_package searches for files called after either of the following patterns:

\begin{itemize}
\item 
<lowercasePackageName>-config.cmake

\item 
<PackageName>Config.cmake

\item 
<lowercasePackageName>-config-version.cmake (if the version details were specified)

\item 
<PackageName>ConfigVersion.cmake (if the version details were specified)
\end{itemize}

All searches will be conducted over a set of locations in a well-defined order; if needed, some of the locations can be skipped by passing the respective option to CMake. find\_package contains a few more options than the other find\_ commands. The following table shows the search order from a high level:

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Location}                     & \textbf{Skip option in the command}  \\ \hline
		Package root variables                & NO\_PACKAGE\_ROOT\_PATH              \\ \hline
		CMake-specific cache variables        & NO\_CMAKE\_PATH                      \\ \hline
		CMake-specific environment variables  & NO\_CMAKE\_ENVIRONMENT\_PATH         \\ \hline
		Paths specified int the HINTS option  &                                      \\ \hline
		System-specific environment variables & NO\_SYSTEM\_ENVIRONMENT\_PATH        \\ \hline
		User package registry                 & NO\_CMAKE\_PACKAGE\_REGISTRY         \\ \hline
		System-specific cache variables       & NO\_CMAKE\_SYSTEM\_PATH              \\ \hline
		System package registry               & NO\_CMAKE\_SYSTEM\_PACKAGE\_REGISTRY \\ \hline
		Paths specified in the PATHS option   &                                      \\ \hline
	\end{tabular}
\end{table}

Let's look at the search order and search locations more closely:

\begin{itemize}
\item 
Package root variables: The package root for each find\_package call is stored in a variable called <PackageName>\_ROOT. They are the first priority for searching files belonging to a package. The package root variables work in the same way as CMAKE\_PREFIX\_PATH, not just for the call to find\_package but for all other find\_ calls that might happen inside the find module belonging to the package.

\item 
CMake-specific cache variables: These are the locations derived from CMAKE\_PREFIX\_PATH. For macOS, the CMAKE\_FRAMEWORK\_PATH variable is also considered a search location.

\item 
By setting the CMAKE\_FIND\_USE\_CMAKE\_PATH variable to false, the locations from the CMake-specific cache variables will be skipped.

\item 
CMake-specific environment variables: In addition to specifying CMAKE\_PREFIX\_PATH and CMAKE\_FRAMEWORK\_PATH as cache variables, CMake will also consider them if they are set as environment variables.

\item 
Setting the CMAKE\_FIND\_USE\_ENVIRONMENT\_PATH variable to false will disable this behavior.

\item 
HINTS from find\_package: These are optional paths passed to find\_package.

\item 
System-specific environment variables: The PATH environment variable is used to look for packages and files and the trailing bin and sbin directories are removed. The default locations for each system, such as /usr, /lib, and similar locations, are usually searched at this point.

\item 
User package registry: Often, packages are found either in the standard locations or in the locations passed to CMake by using the CMAKE\_PREFIX\_PATH option. Package registries are another way to tell CMake where to look for dependencies. Package registries are special locations where collections of packages reside. The user registry is valid for the current user account, while the system package registry is valid system-wide. On Windows, the location for the user package registry is stored in the Windows registry under the following:

\item 
HKEY\_CURRENT\_USER\verb|\|Software\verb|\|Kitware\verb|\|CMake\verb|\|Packages\verb|\|<packageName>\

\item 
On the Unix platform, it is stored in the user's home directory as follows: ~/.cmake/packages/<PackageName>

\item 
Platform-specific cache variables: For find\_package, the platformspecific cache variables, CMAKE\_SYSTEM\_PREFIX\_PATH, CMAKE\_SYSTEM\_FRAMEWORK\_PATH, and CMAKE\_SYSTEM\_APPBUNDLE\_PATH, work in a similar way to the other find calls. They are set by CMake itself and should not be changed by the project.

\item 
System package registry: Similar to the user package registry, this is a location where CMake is looking for packages. On Windows, it is stored under HKEY\_LOCAL\_MACHINE\verb|\|Software\verb|\|itware\verb|\|CMake\verb|\|Packages\verb|\|<packageName>\verb|\|.

\item 
Unix systems do not provide a system package registry.

\item 
PATHS from find\_package: These are optional paths that are passed to find\_package. Usually, the HINTS options are computed from other values or depend on variables, whereas PATHS options are fixed paths.
\end{itemize}

Specifically, when looking for packages in config mode, CMake will look for the following file structure under the various prefixes:

\begin{lstlisting}[style=styleCMake]
<prefix>/
<prefix>/(cmake|CMake)/
<prefix>/<packageName>*/
<prefix>/<packageName>*/(cmake|CMake)/
<prefix>/(lib/<arch>|lib*|share)/cmake/<packageName>*/
<prefix>/(lib/<arch>|lib*|share)/<packageName>*/
<prefix>/(lib/<arch>|lib*|share)/<packageName>*/(cmake|CMake)/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/cmake/
  <packageName>*/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/<packageName>*/
<prefix>/<packageName>*/(lib/<arch>|lib*|share)/<packageName>*/
  (cmake|CMake)/
\end{lstlisting}

On macOS platforms, the following folders are also searched:

\begin{lstlisting}[style=styleCMake]
<prefix>/<packageName>.framework/Resources/
<prefix>/<packageName>.framework/Resources/CMake/
<prefix>/<packageName>.framework/Versions/*/Resources/
<prefix>/<packageName>.framework/Versions/*/Resources/CMake/
<prefix>/<packageName>.app/Contents/Resources/
<prefix>/<packageName>.app/Contents/Resources/CMake/
\end{lstlisting}

You can find out more about packages in the official CMake documentation at \url{https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html}.

In terms of modules, so far, we've only covered how to find existing modules. But what happens if we want to look for dependencies that are neither integrated into CMake, nor in the standard places, or they do not provide configuration instructions for CMake? Well, let's find out about that in the next section.

\subsubsubsection{5.3.1\hspace{0.2cm}Writing your own find module}

While CMake is almost an industry standard, there are still lots of libraries out there that are not managed with CMake or that are managed with CMake but do not export a CMake package. If they can be installed in the default location of a system, finding these libraries is usually not a problem, but this is not always possible or wanted. A common case is when using a proprietary third-party library that is only needed for a certain project or that uses a different version of a library to build from the one that is installed by the systems package manager.

If you're developing multiple projects side by side, you might want to handle the dependencies locally for each project. Either way, it is good practice to set up your project in a way so that dependencies are managed locally and do not depend too much on what is installed on the system. Creating fully reproducible builds is described in Chapter 11, Automated Fuzzing with CMake; however, for now, let's focus on finding dependencies. 

If no module and no configuration file exists for a dependency, often, writing your so-called find module is the solution. The goal is to provide enough information so that, later, we can use any package by using find\_package.

Find modules are instructions for CMake on how to find the necessary header and binary files for a library and which create imported targets for CMake to use. As described earlier in this chapter, when invoking find\_package in module mode, CMake searches for files called Find<PackageName>.cmake in CMAKE\_MODULE\_PATH.

Let's assume that we're building a project where the dependencies have already been downloaded or built and have been placed in a folder called dep before we use them. So, the project structure might look like this:

\begin{tcblisting}{commandshell={}}
├── dep <-- The folder where we locally keep dependencies
├── cmake
│       └── FindLibImagePipeline.cmake <-- This is what we need to write
├── CMakeLists.txt <-- Main CmakeLists.txt
├── src
│       ├── *.cpp files
\end{tcblisting}

The first thing we have to do is to add the cmake folder to the CMAKE\_MODULE\_PATH, which is a list. So, first, we add the following line to the CMakeLists.txt file:

\begin{lstlisting}[style=styleCMake]
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
\end{lstlisting}

This tells CMake that it should look for find modules in the cmake folder. Typically, a find module does things in the following order:

\begin{enumerate}
\item 
It looks for files belonging to the package.
	
\item 
It sets up variables containing the include and library directories for the packages.

\item 
It sets up targets for the imported package.

\item 
It sets properties for the targets.
\end{enumerate}

A simple FindModules.cmake for a library called obscure might look like this:

\begin{lstlisting}[style=styleCMake]
cmake_minimum_required(VERSION 3.21)
find_library(
	OBSCURE_LIBRARY
	NAMES obscure
	HINTS ${PROJECT_SOURCE_DIR}/dep/
	PATH_SUFFIXES lib bin build/Release build/Debug
)

find_path(
	OBSCURE_INCLUDE_DIR
	NAMES obscure/obscure.hpp
	HINTS ${PROJECT_SOURCE_DIR}/dep/include/
)

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(
	Obscure
	DEFAULT_MSG
	OBSCURE_LIBRARY
	OBSCURE_INCLUDE_DIR
)

mark_as_advanced(OBSCURE_LIBRARY OBSCURE_INCLUDE_DIR)

if(NOT TARGET Obscure::Obscure)
	add_library(Obscure::Obscure UNKNOWN IMPORTED )
	set_target_properties(Obscure::Obscure PROPERTIES
		IMPORTED_LOCATION "${OBSCURE_LIBRARY}"
		INTERFACE_INCLUDE_DIRECTORIES
			"${OBSCURE_INCLUDE_DIR}"
		IMPORTED_LINK_INTERFACE_LANGUAGES "CXX"
	)
endif()
\end{lstlisting}

When looking at the example, we can observe that the following things happen:

\begin{enumerate}
\item 
First, the actual library file belonging to the dependency is searched for using the find\_library command. If found, the path to it, including the actual filename, is stored in the OBSCURE\_LIBRARY variable. It is a common practice to name the <PACKAGENAME>\_LIBRARY variable. The NAMES argument is a list of possible names for the library. The names are automatically extended with common prefixes and extensions. So, although, in the preceding example, we look for the name "obscure," a file named libobscure.so or obscure.dll will be found. More details about the search order, hints, and paths will be covered later in this section.

\item 
Next, the Find module attempts to locate the include path. This is done by finding a known path pattern of the library, usually one of the public header files. The result is stored in the OBSCURE\_INCLUDE\_DIR variable. Again, the common practice is to name this variable as <PACKAGENAME>\_INCLUDE\_DIR.

\item 
Since handling all the requirements for a find module can be tedious and is often very repetitive, CMake provides the FindPackageHandleStandardArgs module, which provides a handy function to handle all the common cases. It provides the find\_package\_handle\_standard\_args function, which handles REQUIRED, QUIET, and the version-related arguments of find\_package. find\_package\_handle\_standard\_args has a short signature and a long signature. In the example, the short signature is used:

\begin{lstlisting}[style=styleCMake]
find_package_handle_standard_args(<PackageName>
	(DEFAULT_MSG|<custom-failure-message>)
	<required-var>...
	)
\end{lstlisting}

\item 
For most cases, the short form of find\_package\_handle\_standard\_args is sufficient. In the short form, the find\_package\_handle\_standard\_args function takes the package name as the first argument and a list of variables that are required for the package. The DEFAULT\_MSG argument tells it to print default messages in the event of success or failure, depending on whether find\_package was invoked with REQUIRED or QUIET. The message can be customized, but we recommend that you stick to the default messages whenever possible. That way, the messages are consistent for all the find\_package commands. In the preceding example, find\_package\_handle\_standard\_args checks whether the OBSCURE\_LIBRARY and OBSCURE\_INCLUDE\_DIR variables that have been passed are valid. If that is the case, the <PACKAGENAME>\_FOUND variable is set.

\item 
If all goes well, the find module defines the target. Before we do this, it is helpful to check whether the target we are trying to create does not already exist (to avoid overwriting it in the case that we have multiple calls to find\_package for the same dependency). Creating the target is done with add\_library. Since we cannot be sure whether it is a static or dynamic library, the type is UNKNOWN and the IMPORTED flag is set.

\item 
Finally, the properties for the library are set. The minimum setting that we recommend is the MPORTED\_LOCATION property and the location of the include files in INTERFACE\_INCLUDE\_DIR.
\end{enumerate}

If everything works as expected, the library can then be used like this:

\begin{lstlisting}[style=styleCMake]
find_package(Obscure PRIVATE REQUIRED)
...
target_link_libraries(find_module_example Obscure::Obscure)
\end{lstlisting}

So, now we understand how other libraries are added to your projects if they are already available for use. But how do we get the libraries into our system in the first place? Let's find that out in the next section.

