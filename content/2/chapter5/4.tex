
The easiest way to get dependencies into your project is to regularly install them using apt-get, brew, or Chocolatey. The downside of installing everything is that you can pollute your system with many different versions of libraries and the version you are looking for might not be available at all. This is especially true if you are working on multiple projects with different requirements regarding the dependencies side by side. Often, a developer downloads the dependencies locally for each project so that each project can work independently. A very good way to handle dependencies is by using package managers such as Conan or vcpkg.

Using a dedicated package manager has many advantages when it comes to dependency management. Two of the more popular ones for handling C++ dependencies are Conan and vcpkg. Both of them can handle complex build systems, and mastering them will require whole books on their own, so we will only cover the bare necessities to start working with them here. In this book, we will focus on using packages that are already available in your CMake project, rather than on creating your own packages.

\subsubsubsection{5.4.1\hspace{0.2cm}Getting dependencies from Conan}

Over the last few years, the Conan package manager gained much popularity, mostly because it integrates very well with CMake. Conan is a decentralized package manager that has been built on a client/server architecture. This means that the local client fetches or uploads packages to one or more remote servers.

One of the most powerful features of Conan is that it can create and manage binary packages for multiple platforms, configurations, and versions. When creating packages, they are described with a conanfile.py file that lists all dependencies, sources, and build instructions.

The packages are built and uploaded to the remote server with the Conan client. This has an additional benefit where, if no binary package that fits your local configuration can be found, the package can be built locally from its sources.

A very convenient way to use Conan with CMake is to use Conan from CMake itself. However, if you do not desire to do this, calling Conan externally also works. While not strictly necessary, we recommend that you check for the Conan program using find\_program before using Conan.

To call Conan out of CMake directly, Conan offers a CMake wrapper for downloading. The following example downloads the conan-cmake wrapper and then pulls the fmt formatting library from ConanCenter to be used as a regular library in the project:

\begin{lstlisting}[style=styleCMake]
if(NOT EXISTS "${CMAKE_CURRENT_BINARY_DIR}/conan.cmake")
	message(STATUS "Downloading conan.cmake from
		https://github.com/conan-io/cmake-conan")
	file( DOWNLOAD
		"https://raw.githubusercontent.com/conan-io/cmakeconan/0.17.0/conan.cmake"
		"${CMAKE_CURRENT_BINARY_DIR}/conan.cmake"
		EXPECTED_HASH
		SHA256=3bef79da16c2e031dc429e1dac87a08b9226418b300ce00
			4cc125a82687baeef
		STATUS download_status
	)
	
	if(NOT download_status MATCHES "^0;")
		message(FATAL_ERROR "Downloading conan.cmake failed with
			${download_status}")
	endif()
endif()

include(${CMAKE_CURRENT_BINARY_DIR}/conan.cmake)

conan_cmake_autodetect(CONAN_SETTINGS)

conan_cmake_configure(REQUIRES fmt/6.1.2 GENERATORS cmake_find_
	package_multi)
conan_cmake_install(PATH_OR_REFERENCE .
	BUILD missing
	SETTINGS ${CONAN_SETTINGS}
)

list(APPEND CMAKE_PREFIX_PATH ${CMAKE_CURRENT_BINARY_DIR})
find_package(fmt 6.1 REQUIRED)
add_executable(conan_example)
target_link_libraries(conan_example PRIVATE fmt::fmt)
\end{lstlisting}

The preceding CMake code does the following things:

\begin{enumerate}
\item 
If not already downloaded, the conan.cmake file is downloaded to the current binary directory.

\item 
Next, it is included to make the Conan functions available.

\item 
Once included, Conan is told to detect the settings, such as the compiler, the platform, and more, from the current CMake configuration and to store them in the CONAN\_SETTINGS variable.

\item 
The conan\_cmake\_configure functions define the requirements for fmt and set the generator for Conan so that we can use find\_package to include the dependencies. This will generate a conanfile.txt file that contains the necessary instructions for Conan in the current build directory.

\item 
And, finally, conan\_cmake\_install installs the dependencies.

\item 
PATH\_OR\_REFERENCE tells us where the definition of the dependencies is located. This command runs in the same build directory as conan\_cmake\_configure, so passing a single dot will search the same directory. BUILD missing tells Conan to build the packages locally if they are not available as binaries from the remote server.

\item 
SETTINGS passes the retrieved settings along to Conan.

\item 
Since the generated find modules will be located in the current binary directory, they have to be added to CMAKE\_MODULE\_PATH.

\item 
Once downloaded, the dependencies can be included by using find\_package and then added to the existing targets as usual.
\end{enumerate}

Instead of directly declaring the dependencies inside CMake, it is also possible to provide the information as a conanfile.txt file. It might look something like this:

\begin{lstlisting}[style=styleCMake]
[requires]
fmt/6.1.2
[generators]
cmake_find_package
\end{lstlisting}
 
Here, instead of running conan\_cmake\_configure and conan\_cmake\_install, Conan is invoked through conan\_cmake\_run. Adapting the preceding example to use a conanfile.txt file will look similar to the following (the part that downloads the conan.cmake file stays the same):

\begin{lstlisting}[style=styleCMake]
include(${CMAKE_CURRENT_BINARY_DIR}/conan.cmake)
conan_cmake_autodetect(CONAN_SETTINGS)
conan_cmake_run(CONANFILE ${CMAKE_CURRENT_LIST_DIR}/conanfile.
	txt
	BASIC_SETUP
	BUILD missing
	SETTINGS ${CONAN_SETTINGS})
list(APPEND CMAKE_PREFIX_PATH ${CMAKE_CURRENT_BINARY_DIR})
find_package(fmt 6.1 REQUIRED)
add_executable(conan_conanfile_example)
target_link_libraries(conan_conanfile_example PRIVATE
	fmt::fmt)
\end{lstlisting}

This setup is similar to the previous example, except that Conan is pointed to the conanfile.txt file instead of generating it from the CMake instructions. BASIC\_SETUP will tell Conan to create the necessary CMake variables automatically. The conan\_cmake\_run command can also be used to run almost any Conan command.

Of course, Conan can also be called from outside CMake manually. While some find this to be a cleaner approach, because of the separation of concerns between Conan and CMake, it can be tedious to maintain. Indeed, the information about the dependency has to be tracked in two places, and the build configurations, such as the compilers, the libc version, the platform, and more, have to be configured not just for CMake but for Conan too.

The full Conan documentation can be found at \url{https://docs.conan.io/en/latest/}.

\subsubsubsection{5.4.2\hspace{0.2cm}Using vcpkg for dependency management}






















