
In this section, we will take a look into the two prominent fuzzing tools you can encounter in the wild, namely libFuzzer and AFL++. Let's start by learning about libFuzzer.

\subsubsubsection{11.3.1\hspace{0.2cm}使用libFuzzer}

libFuzzer is a fuzzing library that is part of the LLVM project. It is a compiler-aided fuzzer that has powerful fuzzing techniques, It is the default go-to fuzzer if your project is already compilable with the LLVM toolchain, since using libFuzzer only requires an additional compiler/linker flag and defining a single function. We will start learning more about these details by digging into an example. Let's get our hands dirty.

To showcase fuzzing in practice, we will follow examples as usual. Let's begin with the example in chapter\_11/ex01\_libfuzzer\_static\_lib first. In this example, we have a hypothetical vulnerable static library target, named message\_printer. This is a simple library that has only one interface function, named print(), which takes const char* and length as parameters. We are going to assume this library has a vulnerability that is triggered by an edge-case condition that we haven't been aware of. The implementation of the function looks like this:

\begin{lstlisting}[style=styleCXX]
void message_printer::print(const char *msg, std::uint32_t
len) {
	constexpr char a [] = "Hello from CMake Best
	Practices!";
	if(len < sizeof(a)){
		return;
	}
	if(std::memcmp(a, msg, len) == 0){
		volatile char* ptr{nullptr};
		// attempt to write an invalid memory location
		// it is undefined behavior
		*ptr = 'a';
	}
	/* ... */
}
\end{lstlisting}

The print() function will cause an undefined behavior via dereferencing a null pointer when the msg input exactly contains the string in the a variable, which represents the undiscovered vulnerability in our function. The vulnerability in our example is pretty easy to spot, but real-world vulnerabilities and undefined behaviors will be way more subtle than this.

Okay, we have our target to fuzz in our hands. Up next, we will need a small driver application that will perform the fuzzing by feeding the fuzz data generated by libFuzzer to the message\_printer::print() function. In order to do that, we must link our driver application against message\_printer library and, of course, libFuzzer. Let's take a look into CMakeLists.txt for our example driver application first:

\begin{lstlisting}[style=styleCMake]
add_executable(ch11_ex01_libfuzzer_fuzz)
target_sources(ch11_ex01_libfuzzer_fuzz PRIVATE
	fuzz_library.cpp)
target_compile_features(ch11_ex01_libfuzzer_fuzz PRIVATE
	cxx_std_11)
target_link_libraries(ch11_ex01_libfuzzer_fuzz PRIVATE
	ch11_ex01_libfuzzer_static)
target_compile_options(ch11_ex01_libfuzzer_fuzz PRIVATE -
	fsanitize=fuzzer)
target_link_libraries(ch11_ex01_libfuzzer_fuzz PRIVATE -
	fsanitize=fuzzer)
\end{lstlisting}

We have defined an executable target named ch11\_ex01\_libfuzzer\_fuzz, which links against our fuzzing target, ch11\_ex01\_libfuzzer\_static. Different from usual, there is an additional -fsanitize=fuzzer argument passed to both the compiler and the linker. Passing this argument to the compiler and the linker enables libFuzzer for the LLVM toolchain. Unfortunately, libFuzzer is LLVM-specific and does not work with GCC at the moment. That's it for the CMake side of the fuzzing driver. Let's continue with the code next.

The fuzzing driver implementation is pretty simple. To get the generated fuzzing data from libFuzzer, we need to implement a special function that libFuzzer can recognize. This function is known as the fuzzing entry point. This function has a specific signature and looks like this:

\begin{lstlisting}[style=styleCXX]
extern "C" int LLVMFuzzerTestOneInput(const std::uint8_t
*data, std::size_t size) {
	/* fuzzing entry-point impl. */
}
\end{lstlisting}

The libFuzzer generates fuzzing data as a byte span and calls LLVMFuzzerTestOneInput with the generated byte span. The byte span ranges from \&data[0] to \&data[size-1]. The span should be fed into the fuzzing target in the body of the function. This function is implemented in our driver application, chapter\_11/ex01\_libfuzzer\_static\_lib/fuzz/fuzz\_library.cpp, as follows:

\begin{lstlisting}[style=styleCXX]
#include <cstdint>
#include <library/library.hpp>
extern "C" int LLVMFuzzerTestOneInput(const std::uint8_t
*data,std::size_t size) {
	chapter11::ex01::message_printer printer;
	printer.print(reinterpret_cast<const char *>(data),
		size);
	return 0;
}
\end{lstlisting}

As we can see, the fuzzing function implementation is straightforward. We have constructed an instance of message\_printer and called the print() function with the data and size generated by libFuzzer. The rest is automatically handled by libFuzzer. You may have noticed that the example application does not have a main() function, and that is intentional. The libFuzzer library provides a main() function that bootstraps the fuzzing framework and eventually calls the fuzzing entry point.

Let's see our driver application in action now. As always, let's configure and build our example with the following commands:

\begin{tcblisting}{commandshell={}}
cd chapter_11/
cmake --preset="ninja-debug-clang-13" -S ./ -B build/
cmake --build build/
\end{tcblisting}

As you can see, we have explicitly specified the ninja-debug-clang-13 preset, because we need the clang compiler for our libFuzzer example. After building our example, let's run our fuzzing driver application by executing the following command:

\begin{tcblisting}{commandshell={}}
cd build/ex01_libfuzzer_static_lib/fuzz/
./ch11_ex01_libfuzzer_fuzz
After running for a second, the driver application should
output something like this:

./build/ex01_libfuzzer_static_lib/fuzz/ch11_ex01_libfuzzer_fuzz
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1815993229
INFO: Loaded 1 modules (1 inline 8-bit counters): 1
[0x485fa0, 0x485fa1),
INFO: Loaded 1 PC tables (1 PCs): 1 [0x4723d8,0x4723e8),
INFO: -max_len is not provided; libFuzzer will not generate
inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty
corpus
#2 INITED cov: 1 ft: 1 corp: 1/1b exec/s: 0 rss: 26Mb
UndefinedBehaviorSanitizer:DEADLYSIGNAL
==228856==ERROR: UndefinedBehaviorSanitizer: SEGV on
unknown address 0x000000000000 (pc 0x000000464194 bp
0x7ffdad9733f0 sp 0x7ffdad9733a0 T228856)
==228856==The signal is caused by a WRITE memory access.
==228856==Hint: address points to the zero page.
    #0 0x464194 in chapter11::ex01::message_printer::
    print(char const*, unsigned int) /home/mustafa
    /workspace/personal/CMake-Best-Practices/chapter_11
    /ex01_libfuzzer_static_lib/src/library.cpp:26:14
    #1 0x4640ea in LLVMFuzzerTestOneInput /home/mustafa
    /workspace/personal/CMake-Best-Practices/chapter_11
    /ex01_libfuzzer_static_lib/fuzz/fuzz_library.cpp:7:11
/* ... */
==228856==ABORTING
MS: 4 CopyPart-CMP-CrossOver-CMP- DE: "Hello from CMake
Best Practices!\x004\x97\xad\xfd\x7f\x00\x00\x00dH\x00"-
"Hello from CMake Best Practices!\x004\x97\xad\xfd\
x7f\x00\x00\x00dH\x00.\x00"-; base unit: adc83b19e793491b
1c6ea0fd8b46cd9f32e592fc
0x48,0x65,0x6c,0x6c,0x6f,0x20,0x66,0x72,0x6f,0x6d,0x20,0x43
,0x4d,0x61,0x6b,0x65,0x20,0x42,0x65,0x73,0x74,0x20,0x50,0x7
2,0x61,0x63,0x74,0x69,0x63,0x65,0x73,0x21,0x0,0x34,0x97,0xa
d,0xfd,0x7f,0x0,0x0,0x0,0x64,0x48,0x0,0x2e,0x0,
Hello from CMake Best Practices!\x004\x97\xad\xfd\x7f\x00
\x00\x00dH\x00.\x00
artifact_prefix='./'; Test unit written to ./crash-e95d3
e40c04fcaf86897df986d66f7345bb0d4b1
Base64: SGVsbG8gZnJvbSBDTWFrZSBCZXN0IFByYWN0a
WNlcyEANJet/X8AAABkSAAuAA==
\end{tcblisting}

As you can see, libFuzzer was able to reach the code path that triggers undefined behavior in an instant, even though we have not provided any prior corpus data. The reason for this is that LLVM helps libFuzzer to get more coverage on the target function. As you can imagine, finding the Hello from CMake Best Practices! string with randomly generated data is highly unlikely. It is analogous to cracking a 32-digit password, which means it is practically nearly impossible with today's hardware. With this approach, it is impossible for the fuzzer to reach the code path hidden behind the comparison. So, what LLVM with the -fsanitize=fuzzer flag does here is split the comparison into more manageable, multiple comparisons. For a 32-character-long string, LLVM emits \{N\} small comparisons. So, the resulting comparison is as if we have written code like this:

\begin{lstlisting}[style=styleCXX]
if (*msg[0] == a[0]) {
	if (*msg[1] == a[1]) {
		if (*msg[2] == a[2]) {
			if (*msg[3] == a[3]) {
				/*...*/
			}
		}
	}
}
\end{lstlisting}

Laying out the comparisons in this fashion allows libFuzzer to discover each character via code coverage data quickly. It is still similar to 32-digit password cracking, only this time the password validation system also tells whether you have correctly guessed each digit. This kind of feedback reduces the discovery time from infinity to an instant. Due to this behavior, I refer to libFuzzer as the gray-box fuzzing library. The technique is aware of the implementation; in fact, the technique consists of tailoring the emitted assembly code to make fuzzing more efficient. But I don't think this awareness makes the fuzzing biased. For this reason, I do not consider this approach a fully white-box strategy; also, it is clearly not a black-box strategy. Hence, the term gray-box suitably describes this approach. 

Without a doubt, using a compiler-guided fuzzing toolkit has many benefits. Besides libFuzzer, the LLVM toolchain has many other good utilities up its sleeve, such as Undefined Behavior Sanitizer (UBSan), Address Sanitizer (ASan), and Memory Sanitizer (MSan). Consider investing in supporting LLVM compilation in your projects to benefit from all of these helpful utilities. It is a good idea to enable these tools for fuzzing targets to discover bugs that would otherwise go unnoticed.

With that said, we conclude the libFuzzer part of this chapter. For a real-life example, I
recommend you to take a look at \url{https://google.github.io/clusterfuzz/setting-up-fuzzing/heartbleed-example/} to learn about how OpenSSL's famous Heartbleed vulnerability could have been discovered easily if libFuzzer was used. Also, consider reading LLVM's official libFuzzer documentation at \url{https://llvm.org/docs/LibFuzzer.html}. It contains useful information about libFuzzer's fuzzing concept and usage examples.

Up next, we will investigate another fuzzing tool, the infamous American Fuzzy Lop (AFL).

\subsubsubsection{11.3.2\hspace{0.2cm}使用AFL++}

If you are stuck with GCC for whatever reason and you can't compile your code with LLVM, an alternative fuzzer to libFuzzer is AFL. Unfortunately, the original project is no longer maintained, but don't get downhearted. An even better, enhanced version of the project known as AFL++ is still maintained. In this section of the chapter, we will learn how to use AFL++ with the GCC toolchain.

We will follow an example similar to the previous libFuzzer example. But this time, we will utilize AFL++ and GCC instead of libFuzzer and LLVM. Before moving any further, ensure that a CMake configure preset using afl-gcc and afl-g++ is available under the CMakePresets.json file. The example project already contains such a preset, as shown here:

\begin{lstlisting}[style=styleCMake]
"configurePresets": [
/*...*/
,{
	"name": "afl-gcc",
	"description": "AFL GCC compiler",
	"hidden": true,
	"cacheVariables": {
		"CMAKE_C_COMPILER": {
			"type": "STRING",
			"value": "/usr/bin/afl-gcc"
		},
		"CMAKE_CXX_COMPILER": {
			"type": "STRING",
			"value": "/usr/bin/afl-g++"
		}
	}
},
/*...*/
]
\end{lstlisting}

With that said, let's begin.

In this section, we will follow the chapter11/ex02\_afl\_static\_lib example. In this example, we have a simple, URI decoder implementation that we want to fuzz with AFL++. The URI decoder is intentionally implemented without care, and as a result, it contains severe bugs. URI decoder contains a single method named decode(), which is implemented as follows:

\begin{lstlisting}[style=styleCXX]
char *uri_helper::decode(const char *str) {
	thread_local char result[100];
	for (auto *p = result; *str; ++str) {
		if (*str == '%') {
			const auto a = *++str;
			const auto b = *++str;
			*p++ = (a <= '9' ? a - '0' : a - 'a') * 16 + (b <=
			'9' ? b - '0' : b - 'a');
		} else if (*str == '+') {
			// replace + with space
			*p++ = ' ';
		} else {
			// copy as-is
			*p++ = *str;
		}
	}
	return result;
}
\end{lstlisting}

The intended effects of the function are to replace each two-digit URI encoded character with the corresponding ASCII code, replace the plus (+) sign with a space, and leave all other characters as-is. There are also unintended effects in this implementation, however. The first one is the function not checking whether the result variable has enough space to store the decoded character. This can cause a buffer overrun when the resulting output is greater than the result buffer's size. The second one is the function using the NUL-terminator as a loop condition but incrementing and dereferencing the loop variable, str, without any checks. This results in potential out-of-bounds writes and reads.

I am sure that the number of bugs in this function is proportional to the time spent reviewing it. So, let's begin fuzzing.

In order to fuzz our buggy implementation with AFL++, we need to implement a simple driver application, as we did for the previous libFuzzer example. The driver application consumes our uri\_helper library and feeds the input from standard input to the decode function. The implementation of the driver application is as follows:

\begin{lstlisting}[style=styleCXX]
#include <library/uri_helper.hpp>
#include <iostream>

int main() {
	const auto input = std::string(
		std::istreambuf_iterator<char>(std::cin),
		std::istreambuf_iterator<char>()
	);
	chapter11::ex02::uri_helper uut{};
	std::cout << uut.decode(input.c_str());
}
\end{lstlisting}

The preceding driver application implementation is enough to use it with AFL++. With that sorted out, there is one last thing that needs our attention, which is the initial corpus

data for AFL++. Unlike libFuzzer, AFL++ needs some example inputs to get started. The example input should look like the typical input that the unit-under-test expects. Since our target is a URI decoder, a few URI-encoded strings should do the trick. For that purpose, we have provided a few URI encoded strings under the chapter\_11/ex02\_afl\_static\_lib/corpus folder. So, with everything set, let's compile the example by running the following commands:

\begin{tcblisting}{commandshell={}}
cd chapter_11/
cmake --preset="ninja-debug-afl-gcc" -S ./ -B build/
cmake --build build/
\end{tcblisting}

Note that we are using ninja-debug-afl-gcc as a CMake configure preset. This preset uses afl-gcc and afl-g++ as compilers. This allows AFL++ to perform the required instrumentation over the compiled code, similar to libFuzzer's -fsanitize=fuzzer flag. After the build completes, run the afl-fuzz command against the fuzzing driver, ch11\_ex02\_afl\_fuzz, with the following command:

\begin{tcblisting}{commandshell={}}
afl-fuzz -i ex02_afl_static_lib/corpus/ -o build/FINDINGS -
m none -- build/ex02_afl_static_lib/fuzz/ch11_ex02_afl_fuzz
\end{tcblisting}

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Important note]
If you see an error regarding core dump notifications, that is due to your system using an external utility for handling the core dump notifications. In order to resolve this issue, either apply the recommended action by afl-fuzz or prepend AFL\_I\_DONT\_CARE\_ABOUT\_MISSING\_CRASHES=1 to the afl-fuzz command before executing. Note that the second option is only recommended for demonstration purposes and not recommended for daily use.
\end{tcolorbox}

The command may look scary at first glance, but it is pretty simple. Let's dissect the command as parameters one by one. The -i ex02\_afl\_static\_lib/corpus/parameter is used for specifying the corpus data, the example encoded URIs, as we have talked about before. The -o build/FINDINGS parameter is the path for saving interesting findings that AFL++ will make. All the input that causes weird behavior such as crashes and stalls will be saved here. Lastly, the -m none parameter is for specifying the memory limit for the run, where none stands for no limit. After running the command, you should be seeing the AFL++'s fuzzing progress report screen, as shown here:

\begin{center}
\includegraphics[width=0.8\textwidth]{content/2/chapter11/images/1.jpg}\\
Figure 11.1 – The AFL++ fuzzing progress screen
\end{center}

There are interesting statistics presented on the screen. The most prominent ones are uniq crashes and uniq hangs, which are the statistics for the number of unique crashes and hangs on this fuzzing run. If these numbers are non-zero, this means the fuzzer may have found some bugs on the unit-under-test. The fuzzer will continuously generate new input, and statistics will be updated accordingly. You may need to wait from several minutes to weeks before anything interesting happens. After letting the tool work for a few minutes, it will begin to discover a few unique crashes, as shown in the following screenshot:

\begin{center}
\includegraphics[width=0.8\textwidth]{content/2/chapter11/images/2.jpg}\\
Figure 11.2 – The AFL++ fuzzing progress screen after discovering some crashes
\end{center}

Let's cancel the run by pressing Ctrl + C on the keyboard and take a look at the input that caused the reported crashes. The crash-causing input should be saved under the chapter\_11/build/FINDINGS/default/crashes folder. For the illustrated run, there are four crash logs in the crashes/ folder, as can be seen here:

\begin{center}
\includegraphics[width=0.8\textwidth]{content/2/chapter11/images/3.jpg}\\
Figure 11.3 – The crash-causing input discovered by AFL++
\end{center}

Let's take a look at the contents of the first file (starting with id:000000):

\begin{tcblisting}{commandshell={}}
x=%���%B9D0JJJJJJJJJJJJJJJJJJJJJ���������������������
��������D1%88%D0JJJJJJJJJ%I5������������������������
�������%D0%B9D0JJJJJJJJJJJJJJJJJJJJJJJIJJJJJJ%BB%D1%XB
\end{tcblisting}

AFL++ has reported that our test driver application, ch11\_ex02\_afl\_fuzz, has crashed with this input. Let's check that is indeed the case by running the driver application manually with the preceding string:

\begin{tcblisting}{commandshell={}}
18:09 $ ./build/ex02_afl_static_lib/fuzz/ch11_ex02_afl_
fuzz <<< x=x=%���%B9D0JJJJJJJJJJJJJJJJJJJJJ���������������������
��������D1%88%D0JJJJJJJJJ%I5������������������������
�������%D0%B9D0JJJJJJJJJJJJJJJJJJJJJJJIJJJJJJ%BB%D1%XB
Segmentation fault
\end{tcblisting}

The test driver crashes due to a segmentation fault, which means the program is accessing a memory location that is not allowed for the program to access, which is likely caused by a buffer overrun in the result array in the decode() method. It seems AFL++ has succeeded in discovering a bug in our URL decoder. From this point on, it is a pretty straightforward bug-fixing process. Run the program under the debugger, give the input, and diagnose.








