Software testing is crucial for ensuring that a software system behaves as expected. Unsurprisingly, the need for scenario-based testing strategies is still at its peak. But the scenario-based approach often does not suffice. The real world is wild. Things out there are not sterile as in a test environment. Many different variables contribute to a software's behavior. Environments, users, hardware, operating systems, or third-party libraries can affect software unexpectedly. As software becomes more extensive, it becomes painfully hard to come up with a testing suite that covers all possible aspects of it. Therefore, the need for a technique that performs the unexpected arises. Thankfully, fuzzing comes to the rescue.

In this chapter, we will learn the basics of fuzzing and learn how to use this technique 
to test our software to make it more reliable. Furthermore, we will learn how we can integrate fuzzing tools into CMake to easily define fuzzing targets.

To understand the skills shared in this chapter, we'll cover the following main topics:

\begin{itemize}
\item 
A brief look at fuzzing in CMake projects

\item 
Integrating AFL/libfuzzer into your CMake project
\end{itemize}

Let's begin with the technical requirements.
























