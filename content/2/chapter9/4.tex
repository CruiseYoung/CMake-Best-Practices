In a nutshell, a system root, or just sysroot, is a directory that a build system considers to be the root directory from which to locate headers and libraries. In brief, they contain a stripped-down version of the root filesystem for the platform for which software is being compiled. They are often used when cross-compiling software for other platforms, as described in Chapter 12, Cross-Platform Compiling and Custom Toolchains. If containers for shipping whole build environments are not an option, sysroots can be an alternative to provide a defined build environment.

To use a sysroot with CMake, a toolchain file is needed. As the name suggests, these files define the tools to use to compile and link the software as well as where to find any libraries. In a normal build, CMake automatically detects the toolchain by introspecting the system. Toolchain files are passed to CMake with the CMAKE\_TOOLCHAIN\_FILE variable like this:

\begin{tcblisting}{commandshell={}}
cmake -S <source_dir> -B <binary_dir> -DCMAKE_TOOLCHAIN_FILE=
  <path/to/toolchain.cmake>
\end{tcblisting}

Since version 3.21, CMake additionally supports the -{}-toolchain option to pass toolchain files, which is equivalent to passing the CMAKE\_TOOLCHAIN\_FILE cache variable.

Alternatively, the toolchain file can be passed with a CMake preset as a cache variable. At a minimum, a toolchain file to use with a sysroot will define the CMAKE\_SYSROOT variable to point to the sysroot and the CMAKE\_<LANG>\_COMPILER variable to point to a compiler that is compatible with the libraries in the sysroot. To avoid mixing dependencies from outside the sysroot with the files installed on the host system, the variables for controlling where the find\_ commands look for stuff are usually also set. A minimal toolchain file might look like this:

\begin{lstlisting}[style=styleCMake]
set(CMAKE_SYSTEM_NAME Linux)

set(CMAKE_SYSROOT /path/to/sysroot/)
set(CMAKE_STAGING_PREFIX path/to/staging/directory)

set(CMAKE_C_COMPILER /path/to/sysroot/usr/bin/gcc-10)
set(CMAKE_CXX_COMPILER /path/to/sysroot/usr/bin/g++-10)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)
\end{lstlisting}

Let's see what happens here in detail:

\begin{enumerate}
\item 
First, the system name of the target system is set, by setting the CMAKE\_SYSTEM\_NAME variable. This is the system for which the files are compiled inside the sysroot.

\item 
Then, the path to the sysroot itself is set by setting the CMAKE\_SYSROOT variable. CMAKE\_STAGING\_PREFIX is optional and is used to specify a location on the host machine to install any artifacts of the project. Specifying a staging prefix helps keep the sysroot and the host filesystem clean, as without it, any installation of the artifacts will happen on the host filesystem.

\item 
Next, the compilers are set to the compilers binaries delivered with the sysroot by setting the CMAKE\_C\_COMPILER and CMAKE\_CXX\_COMPILER variables.

\item 
Lastly, the search behavior of any find\_ command in CMake is set. The CMAKE\_FIND\_ROOT\_PATH\_MODE\_* variables take any of the values of ONLY, NEVER, and BOTH. If set to ONLY, CMake will only search the type of file inside the sysroot; if set to NEVER, searches will only consider the host file structure. If set to BOTH, then the host system path and the sysroot path will be searched. Note that CMAKE\_STAGING\_PREFIX is considered a system path, so in order to search the sysroot and the staging directory, BOTH must be selected. In the example, this is configured in a way that all header files and libraries are restricted to the sysroot, while any call for find\_program will look only on the host system and find\_package will look in both places.
\end{enumerate}

Setting the CMAKE\_SYSROOT variable will not automatically set the place where build artifacts are installed. For situations where the resulting binaries are compatible with the host system, this might be the intended behavior. In a lot of cases, such as when cross-compiling, this is not what is wanted, so setting CMAKE\_STAGING\_PREFIX is often recommended. Setting the staging directory has two effects: first, it will cause any artifacts to be installed in the staging directory, and second, the staging directory will be added to the search prefix for the find\_ commands. One caveat is that the staging directory will be added to CMAKE\_SYSTEM\_PREFIX\_PATH, which has the downside that the CMAKE\_FIND\_ROOT\_PATH\_MODE\_XXX variables from the preceding example have to be set to BOTH so the packages, libraries, and programs installed in the staging area are found.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=CMAKE\_STAGING\_PREFIX and CMAKE\_INSTALL\_PREFIX]
If both CMAKE\_STAGING\_PREFIX and CMAKE\_INSTALL\_PREFIX are set, the staging prefix will take precedence. So, as a rule of thumb, whenever the toolchain is compatible with the host system, the staging might be omitted, else it tends to be defined.
\end{tcolorbox}

One downside of sysroots compared to containers is that they cannot be started and be used to execute commands within just like that. So, if the toolchain and the sysroot are not compatible with the host platform, any files produced will not be executable without either moving to the target platform or using an emulator.





























