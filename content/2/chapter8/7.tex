In this chapter, you learned how to customize a build by executing external tasks and programs. We covered how to add custom build actions as targets, how to add them to existing targets, and how to execute them during the configuration step. We went over how commands can generate files and how CMake can copy and modify files with the configure\_file command. Finally, we learned how the CMake command-line utility can be used to perform tasks in a platform-independent manner.

The ability to customize a CMake build is a very powerful tool but it also tends to make builds more brittle as the complexity of the builds often increases when any customized tasks are performed. Although sometimes not avoidable, relying on external programs other than a compiler and linker being installed may mean that a piece of software can be built on a platform where those programs haven't been installed or aren't available. This means special care must be taken to ensure that custom tasks do not assume anything about the system around CMake if possible. Lastly, executing custom tasks may carry a performance penalty for the build system, especially if they do heavy work on each build.

But if you are careful with custom build steps, they are a great way of increasing the cohesion of a build as many of the build-related tasks can be defined where the build definition is. This can make automating tasks such as creating hashes of the build artifacts or assembling all the documents in a common archive much easier.

In the next chapter, you will learn how to make the build environment portable between different systems. You will learn about how to use presets to define common ways to configure a CMake project, as well as how to wrap your build environment into a container and use sysroots to define toolchains and libraries as being portable between systems.