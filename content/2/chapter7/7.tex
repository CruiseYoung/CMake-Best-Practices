Maintaining high software quality is a huge and complex task, and today, there is such a multitude of tools and techniques to test software that it can be hard to keep an overview. With the techniques and the tools described in this chapter, we hope to have given a brief overview of the most common tasks and tools used in modern C++ development. CTest and CMake can help orchestrate the various kinds of tests to get the most out of the tools. In this chapter, you've seen how tests can be defined and run, how to execute them in parallel, and how to manage test resources. We've gone over how to define test fixtures and how to define advanced ways to determine whether a test succeeded or failed based on its output.

We have illustrated how to set up code coverage reports using Gcov and how to define custom build types to pass the needed compiler flags. We've looked at how various tools for static code analysis can be included in CMake projects and how the sanitizers of various compilers can be used. And, in the end, we've briefly covered defining and running micro-benchmarks using the Catch2 framework.

In the next chapter, we will see how to use external programs to format your code and speed up your build.