So far, we have only talked about build types such as Debug, Release, RelWithDebInfo, and MinSizeRel, which are provided by CMake by default. These build types can be extended with custom build types that pass global flags to all targets. For the code quality tools that rely on certain compiler flags, providing a custom build type can simplify CMakeLists.txt considerably, especially for large projects. Creating a custom build type is also much preferred to directly interfere with the global CMAKE\_<LANG>\_FLAGS.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Do Not Override CMAKE\_<LANG>\_FLAGS]
Setting the global compiler option is preferred over the generic CMAKE\_<LANG>\_FLAGS in your CMakeLists.txt. These flags are intended to be set outside the project, either by passing them over the command line or by supplying them with a toolchain file. Modifying them inside a project has a high chance of interfering with the cases where they are set from the outside.
\end{tcolorbox}

For multi-configuration generators such as MSVC or Ninja Multi-Config, the available build types are stored in the CMAKE\_CONFIGURATION\_TYPES cache variable. For single configuration generators such as Make or Ninja, the current build type is stored in the CMAKE\_BUILD\_TYPE variable. Custom build types should be defined on the top-level project.

A custom build type called Coverage could be added to CMakeLists.txt like this:

\begin{lstlisting}[style=styleCMake]
get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_
	MULTI)
if(IS_MULTI_CONFIG_GENERATOR)
	if(NOT "Coverage" IN_LIST CMAKE_CONFIGURATION_TYPES)
		list(APPEND CMAKE_CONFIGURATION_TYPES Coverage)
	endif()
else()

set(KNOWN_BUILD_TYPES Debug Release RelWithDebInfo Coverage)
set_property(CACHE CMAKE_BUILD_TYPE
	PROPERTY STRINGS ${KNOWN_BUILD_TYPES}
)
if(NOT CMAKE_BUILD_TYPE IN_LIST KNOWN_BUILD_TYPES)
	message(FATAL_ERROR "Unknown build type: ${CMAKE_BUILD_
		TYPE}")
endif()
\end{lstlisting}

Let's see what happens in the preceding example:

\begin{itemize}
\item 
First, it is determined whether the current Generator is a multi or single configuration generator. This is stored in the GENERATOR\_IS\_MULTI\_CONFIG global property. Since the property cannot be used directly in an if statement, the property is retrieved and stored in the IS\_MULTI\_CONFIG variable.

\item 
If the current generator is indeed a multi-configuration generator, the custom build configuration called Coverage is added to CMAKE\_CONFIGURATION\_TYPES and made available to the generator, but only if it does not yet exist.

\item 
If the generator is a single configuration generator, a hint that the Coverage build exists is added by setting the STRINGS property of the CMAKE\_BUILD\_TYPE cache variable. This will create a drop-down menu with the valid options in the CMake GUI. For convenience, the supported build types are stored in the KNOWN\_BUILD\_TYPES variable

\item 
As the current build type is usually supplied from the outside for single configuration generators, it is prudent to check for unknown build types and abort the configuration if an unknown build type was specified. Printing a message as FATAL\_ERROR will cause CMake to stop the build.
\end{itemize}

With this, the Coverage build type is added to CMake, but the build type is not yet configured to add a custom compiler and linker flags to the build. To define the flags, two sets of cache variables are used:

\begin{itemize}
\item 
CMAKE\_<LANG>\_FLAGS\_<CONFIGURATION>

\item 
CMAKE\_<TARGET\_TYPE>\_LINKER\_FLAGS\_<CONFIGURATION>
\end{itemize}

<CONFIGURATION> is the name of the custom build type, <LANG> is the programming language, and <TARGET\_TYPE> for the linker flags are either executable or the various types of libraries. It can be useful to base the configuration for the custom build on existing build types to reuse any of the configuration options. The following example sets up the Coverage build type for a Clang or GCC compatible compiler based on the flags of the Debug build type:

\begin{lstlisting}[style=styleCMake]
set(CMAKE_C_FLAGS_COVERAGE
	"${CMAKE_C_FLAGS_DEBUG} --coverage" CACHE STRING ""
)
set(CMAKE_CXX_FLAGS_COVERAGE
	"${CMAKE_CXX_FLAGS_DEBUG} --coverage" CACHE STRING ""
)
set(CMAKE_EXE_LINKER_FLAGS_COVERAGE
	"${CMAKE_EXE_LINKER_FLAGS_DEBUG} --coverage" CACHE STRING ""
)
set(CMAKE_SHARED_LINKER_FLAGS_COVERAGE
	"${CMAKE_SHARED_LINKER_FLAGS_DEBUG} --coverage"
	CACHE STRING ""
)
\end{lstlisting}

The flags can also contain generator expressions to account for different compilers when setting the flags. Marking the flags as advanced will help prevent accidental changes to the variables by the user:

\begin{lstlisting}[style=styleCMake]
mark_as_advanced(CMAKE_C_FLAGS_COVERAGE
				CMAKE_CXX_FLAGS_COVERAGE
				CMAKE_EXE_LINKER_FLAGS_COVERAGE
				CMAKE_SHARED_LINKER_FLAGS_COVERAGE
				CMAKE_STATIC_LINKGER_FLAGS_COVERAGE
				CMAKE_MODULE_LINKER_FLAGS_COVERAGE
)
\end{lstlisting}

Sometimes the filename for libraries should reflect that they are created with a special build type. Setting CMAKE\_<CONFIGURATION>\_POSTFIX for the custom build type will achieve that. This is already common practice for debug builds so the files can be distinguished from the release build when packaged together. Related to this is the DEBUG\_CONFIGURATIONS global property, which contains the configurations that are considered non-optimized and are used for debugging. If the custom build is considered a non-release build, adding to the property, as follows, should be considered:

\begin{lstlisting}[style=styleCMake]
set_property(GLOBAL APPEND PROPERTY DEBUG_CONFIGURATIONS
	Coverage)
\end{lstlisting}

The DEBUG\_CONFIGURATION property should be set on the top-level project before any calls to target\_link\_libraries. The DEBUG\_CONFIGURATIONS property is currently only used by target\_link\_libraries where, for historical reasons, the libraries can be prefixed with debug or optimized to indicate that they should only be linked for the respective build configuration. Nowadays, this is rarely used, as generator expressions allow for more granular control of this.

With this, we conclude this chapter. We have covered the most common aspects of testing and quality tools, and hope that we can contribute to your journey towards excellent software quality.













